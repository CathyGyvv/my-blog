## 原型
下图是关于原型原型链最完整的图，先把它放出来镇楼。。。不着急，下面会慢慢的去理这个图的关系。
![](https://user-gold-cdn.xitu.io/2019/12/3/16ec8eefc33d2c15?w=638&h=801&f=png&s=276693)


要理清那个大图，首先我们要知道构造函数是啥。构造函数就是可以创建特定类型对象的函数。
下面给一个示例，这个示例在本篇文章中一直用。
```js
function Foo(name) {
    this.name = name
}

Foo.prototype.sayName = ()=> {
    console.log(this.name)
}
var f1 = new Foo('f1'); // new 了一个Foo的实例,f1
console.log(f1);

var f2 = new Foo('f2'); // new 了一个Foo的实例,f2
console.log(f2);

console.log(Foo.prototype)
```
下面是打印结果
![](https://user-gold-cdn.xitu.io/2019/12/8/16ee36569ef1a226?w=418&h=227&f=png&s=19450)


![](https://user-gold-cdn.xitu.io/2019/12/8/16ee367e2e3be1c4?w=351&h=94&f=png&s=9144)
Foo是一个构造函数，大写首字母是规范，f1，f2是Foo的实例。
先看f1,f2，都有一个_proto_属性。通过《高程》得知，
f1._proto_，f2._proto_指向一个原型对象，再看Foo,有一个Prototype属性，只要创建新函数，就会给该函数创建这个属性，Foo.prototype也指向一个原型对象，它俩指向同一个原型对象。Foo.prototype上有一个constructor属性,是一个指向prototype所在的函数的指针，这里自然指向了Foo，所有Foo实例都会共享Foo.prototype上的属性和方法。
```js
代码说明
f1._proto_ === Foo.prototype // true
f2._proto_ === Foo.prototype // true
f1._proto_ === f2._proto_ // true ,都是同一个对象的引用
Foo.prototype.constructor === Foo // true
```
这部分对应大图的这一部分。

![](https://user-gold-cdn.xitu.io/2019/12/8/16ee37bc5fa10cc1?w=618&h=781&f=png&s=274646)
同理，图中部分也解释的通。

![](https://user-gold-cdn.xitu.io/2019/12/8/16ee382bd653f2bf?w=618&h=781&f=png&s=275032)
然后，再看Foo.prototype,先前说了它指向原型对象，原型对象也是对象，是对象就有_proto_属性，而且对象都是原生对象Object的实例，所以得出下面结论。
```js
Foo.prototype._proto_ === Object.prototype // true
Object.prototype._proto_ === null // true 这个比较特殊
```
图中这部分也解释通了

![](https://user-gold-cdn.xitu.io/2019/12/8/16ee387a29366cc7?w=618&h=781&f=png&s=275649)

在Javascript中，函数也属于对象,不管函数是通过new Function的实例还是function关键字声明的函数，也会有_proto_属性,指向Function.prototype。


![](https://user-gold-cdn.xitu.io/2019/12/8/16ee3fdf53f8b53c?w=327&h=306&f=png&s=17615)
解释了下图的红线表记的部分。

![](https://user-gold-cdn.xitu.io/2019/12/8/16ee3ff7e132ea6c?w=618&h=781&f=png&s=275056)
至此，大图的所有逻辑都走了一遍。

##原型链

f1,f2不光可以调用Foo.prototype上的方法，还可以调用Object.prototype上的方法,看图，由_proto_组成的链条就是原型链。

![](https://user-gold-cdn.xitu.io/2019/12/8/16ee38bc232077d1?w=618&h=781&f=png&s=279000)

顺便看一个ES5的方法,可以获得对象的原型,代替obj.__proto__ 这种写法
Object.getPrototypeOf([实例])

当获取一个对象上的属性时，会先从此对象上查找，如果没找到，就去原型上找，找到了就返回此属性值，如果原型上有，就返回此属性值，如果没有，就是undefined。
```js
function Parent() {}
Parent.prototype.name="ParentName";
var parent1 = new Parent();
parent1.name = 'parentName';
console.log(parent1.name) // parentName
parent1.name = 'parentName22'; //修改的也是实例上的属性，非原型对象上的属性
console.log(parent1.name) // parentName22
```
hasOwnProperty判断属性来自实例还是原型
```js
function Parent(){}
Parent.prototype.attr='123';
var p = new parent();
p.name = 'pName';
console.log(p.hasOwnProperty('name')) // true,来自实例。
console.log(p.hasOwnProperty('attr')) // false,来自原型对象
```


for in 可以遍历原型上的属性，只要其可枚举
Object.keys()
Object.getOwnPropertyNames() 一把锁  
这部分写的很糙，是因为《高程》上写的实在是太好了，我也不想直接抄过来，建议直接看《高程》


