```js
  function fn(){
    var a = 0;
    function foo() {
      return ++a;
    }
  }

  fn()
  foo() // 报错，没有对foo函数的引用，被当作垃圾回收
```


js采用词法作用域，就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的，为了实现这种词法作用域，js函数对象的内部状态不仅包含函数的代码逻辑还必须引用当前的作用域链，函数对象可以通过作用域链相互关联起来。函数体内部的变量都可以保存在函数作用域内。如果你理解了词法作用域的规则，就能很容易的理解闭包，函数定义时的作用域链到函数执行时依然有效。有些人不理解，认为在外部函数中定义的局部变量在函数返回后就不存在了，那么嵌套的函数如何能调用不存在的作用域链？每次调用js函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中，当函数返回的时候，就从作用域链中将这个绑定变量的对象删除，所以我们在函数调用后，获取不到函数执行后的局部变量。如果不存在嵌套函数（闭包），也没有其他引用指向这个绑定对象，他就被当作垃圾回收掉.


  上期思考题解
代码1：
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

checkscope()();                  ```
代码2：
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope(); 
foo(); 
```
上面的两个代码中，checkscope()执行完成后，闭包f所引用的自由变量scope会被垃圾回收吗？为什么？

解答：

checkscope()执行完成后，代码1中自由变量特定时间之后回收，代码2中自由变量不回收。

首先要说明的是，现在主流浏览器的垃圾回收算法是标记清除，标记清除并非是标记执行栈的进出，而是从根开始遍历，也是一个找引用关系的过程，但是因为从根开始，相互引用的情况不会被计入。所以当垃圾回收开始时，从Root（全局对象）开始寻找这个对象的引用是否可达，如果引用链断裂，那么这个对象就会回收。

闭包中的作用域链中 parentContext.vo 是对象，被放在堆中，栈中的变量会随着执行环境进出而销毁，堆中需要垃圾回收，闭包内的自由变量会被分配到堆上，所以当外部方法执行完毕后，对其的引用并没有丢。

每次进入函数执行时，会重新创建可执行环境和活动对象，但函数的[[Scope]]是函数定义时就已经定义好的（词法作用域规则），不可更改。

对于代码1：
checkscope()执行时,将checkscope对象指针压入栈中，其执行环境变量如下
```js
checkscopeContext:{
    AO:{
        arguments:
        scope:
        f:
    },
    this,
    [[Scope]]:[AO, globalContext.VO]
}
```
执行完毕后出栈，该对象没有绑定给谁，从Root开始查找无法可达，此活动对象一段时间后会被回收

对于代码2：
checkscope()执行后，返回的是f对象，其执行环境变量如下
```js
fContext:{
    AO:{
        arguments:
    },
    this,
    [[Scope]]:[AO, checkscopeContext.AO, globalContext.VO]
}
```
此对象赋值给var foo = checkscope();，将foo压入栈中，foo指向堆中的f活动对象,对于Root来说可达，不会被回收。

如果一定要自由变量scope回收，那么该怎么办？？？

很简单，foo = null;，把引用断开就可以了。