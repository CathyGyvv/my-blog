## 创建正则的两种方式

1.创建RegExp对象
```js
// JavaScript中有一个特殊对象，RegExp对象
var reg = new RegExp('a'); 
'12a3'.replace(reg, '&');  // '12&3'
```
2.直接创建
```js
var reg = /a/;
'12a3'.replace(reg, '&'); // '12&3'
```

两种创建方式的区别在于，第一种可以创建动态正则
```js
var str = '2';
var reg = /str/;   // 这里的str只是单纯的字符串'str'
reg.test('123'); // false
reg.test('11str22'); // true


var newReg = new RegExp(str);  // 这里的str是一个变量,也就是字符串2
reg.test('123'); //true
reg.test('11str22') // false
```

正则其实只匹配字符和位置，这句话概括了正则的精髓。
## 修饰符  
g  表示全局匹配  
```js
'123'replace(/2/,)
```
i  表示不区分大小写  
m  表示匹配换行  


这里只列举常用的，更多请查询[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)

## 特殊字符
> 普通的特殊字符  

- .    匹配特殊字符 

- \d  匹配数字  
- \D  匹配非数字
- \b  匹配字符边界
- \B  匹配非字符边界 
- \s 匹配空白字符
- \S  匹配非空白字符
- \w 匹配字母数字或下划线  
- ()  捕获括号
```js
// \1 相当于第一个括号里的内容，也就是foo,\2同理
/(foo) (bar) \1 \2/.test('foo bar foo bar'); // true
```

- x(?=y) 先行断言
```js
// 匹配字符j,后面紧跟s字符的j,只匹配j
'jsji'.replace(/j(?=s)/,'@'); // @sji
```

- x(?!y) 正向否定查找（相当于先行断言的取反）
```js
// 匹配j,后面不跟s字符的j，只匹配j
'jsjije'.replace(/j(?!s)/g, '@'); // js@i@e

```

- (?<=y)x  后行断言

```js
// 匹配字符s,前面紧跟j字符的s,只匹配s
'jsis'.replace(/(?<=j)s/,'@'); // j@is
```

- (?<!y)x  反向否定查找（相当于后行断言的取反）
```js
// 匹配字符s,前面不跟j字符的s，只匹配s
'jsisys'.replace(/(?<!j)s/g,'@'); // jsi@y@
```
- x|y  | 表示'或'
- [a-z] 字符集
- [^a]  取反  

这里只列举常用的，更多请查询[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)

> 描述数量的特殊字符  

描述数量的特殊字符前面必须跟有效的字符（没字符的话描述谁的数量呢）

| 字符 | 描述 |
|------|------|
| \+  | 表示字符出现一次或多次，等价于{1,}  | 
| \* | 表示字符出现0次或多次，等价于{0,}   |
|? |表示字符出现0次或1次，等价于{0,1}  |
|{n}|表示字符出现2次 |
|||
|||
  
 
 
 
{2,5} 表示字符出现2-5次  
{2,} 表示字符出现2次或多次（大于2）  

> 常用方法  

test()  
replace()
