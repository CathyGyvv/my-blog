js程序是用Unicode字符集编写的，采用UTF-6编码的Unicode字符集,,Unicode是ASCII的超集，并支持几乎所有的语言。

普通字符串为什么可以调用方法？
只要引用了字符串的属性，js就会将字符串值通过new String()的方式转换为一个临时对象，继承了字符串的方法，一旦属性引用结束，这个新创建的对象就被销毁。null和undefined之所以没有方法调用，是因为他们没有包装对象。
```js
var s='test';
s.len = 4; // 设置一个属性
var t=s.len; // undefined

```

第二行代码创建一个临时字符串对象，给其len属性赋值4，随即销毁这个对象，第三行通过原始的字符串值创建一个新字符串对象，读取其len属性，自然不存在。说明，在读取字符串，数字，布尔值的属性和方法的时候，表现的确实和对象一样，富国你禅师给其属性赋值，则忽略次操作，修改之事发生在临时对象上，临时对象并未继续保留下来。这个临时对象也叫包装对象，只是一种实现细节。


作用域：
  在一些类似C语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明他们的代码段之外是不可见的，我们称之为块级作用域，而js在es6之前是没有块级作用域。使用了函数作用域，变量在声明他们的函数体以及这个函数体嵌套的任何函数体内都是有定义的。在函数内声明的所有变量在函数体内始终是可见的。
  ```js
  var scope='global';
  function fn() {
    console.log(scope); // undefined,而不是global
    var scope='local';
    console.log(scope) // local
  }

  上述代码等价于
  function fn() {
    var scope; // 声明局部变量
    console.log(scope)； // 变量存在，未初始化赋值，所以是undefined
    scope='local'; // 初始化赋值
    console.log(scope) // local
  }
  ```
  犹豫js没有块级作用域，因此程序员们有习惯将声明变量放在函数体顶部，而不是将声明靠近放在使用变量之处，这种做法是的代码非常清晰的反应真实的变量作用域。

  当声明一个js全局变量时，实际上时定义了全局对象的一个属性，当使用var声明一个变量时，创建的这个属性时不可配置的，无法通过delete运算符删除。如果没有用严格模式并给一个未声明的彬良赋值的话，js会自动创建一个全局变量，这种方式创建的变量，可被删除。

  ```js
  var a=1; // 声明了一个不可被删除的全局变量
  b=2; // 创建全局对象的一个可删除的属性
  this.c = 3; // 同上
  delete a // false,没有被删除
  delete b // true 被删除
  delete this.c // true
```

## 作用域链
  每一段js代码（全局代码或者函数），都有一个与之关联的作用域链，这个作用域链是一个对象列表或者链表，这组对象定义了这段代码‘作用域中’的变量。当js需要查找变量X的值时，这个过程叫做变量解析，他会从链中第一个对象开始查找，如果这个对象有一个名为X的属性，则会直接使用这个属性的值，如果不存在，js继续查找链上的下一个对象，如果还没有，继续往上找，以此类推。如果作用域链上没有任何一个对象含有X属性，那么就认为这段嗲吗的作用域链上不存在X，抛引用错误异常。
  这就引出了
  词法作用域。！！！！

语句和表达式之间有很多公共之处，粗略的讲，表达式仅仅计算出一个值，但并不做任何操作，他不改变程序的运行状态，而语句改变程序的运行状态。


## 垃圾回收机制
  js解释器有自己的内存管理机制，可以自动对内存进行垃圾回收，这意味着程序可以按需创建对象，当不再有任何引用指向一个对象，解释器就知道这个对象没用了，自动回收它所占用的内存资源。


  ## 字符串
    是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集字符串的长度是其所含16位值的个数