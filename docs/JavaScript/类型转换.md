6种基本数据类型。 
怎么判断数据类型？？
3种方式
Object.prototype.toString.call()  怎么理解？？？
Object.prototype上的tostring方法和function.prototype上的
tostring方法不一样啊，Array.prototype上的tostring方法是经过重写的啊，join方法类似


(!a && typeof a === "object"); // 检查null的类型

typeof function a(){ /* .. */ } === "function"; // true
这样看来，function（函数）也是 JavaScript 的一个内置类型。然而查阅规范就会知道，
它实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属
性 [[Call]]，该属性使其可以被调用。
函数不仅是对象，还可以拥有属性。例如：
function a(b,c) {
 /* .. */
}
函数对象的 length 属性是其形参的个数：
arguments.length是实参的个数
a.length; // 2


大多数开发者倾向于将 undefined 等同于 undeclared（未声明），但在 JavaScript 中它们完全
是两回事。
已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明
过的变量，是 undeclared 的。
例如：
var a;
a; // undefined
b; // ReferenceError: b is not defined
浏览器对这类情况的处理很让人抓狂。上例中，“b is not defined”容易让人误以为是“b is
undefined”。这里再强调一遍，“undefined”和“is not defined”是两码事。此时如果浏览器
报错成“b is not found”或者“b is not declared”会更准确。
更让人抓狂的是 typeof 处理 undeclared 变量的方式。例如：
var a;
typeof a; // "undefined"
typeof b; // "undefined"
对于 undeclared（或者 not defined）变量，typeof 照样返回 "undefined"。请注意虽然 b 是
一个 undeclared 变量，但 typeof b 并没有报错。这是因为 typeof 有一个特殊的安全防范
机制。
此时 typeof 如果能返回 undeclared（而非 undefined）的话，情况会好很多。


null == undefined // true ，没有任何类型转换，可以当作特例
有一方是数字，就像数字转换，
两方为字符串和布尔值，都转换为数组
undefined和null 不能转换为对象
NaN和任何类型的变量相加都为NaN
字符串类型和任何相加都为字符串

Number，parseInt，parseFloat 3个的区别。

x + '' // 转换为字符串
+x // 数字
!!x // 布尔值

## 主要在于+和==的类型转换
特例:
  {}+[] // [object,object]

parseint() ,parseFloat必须以数字开头，否则NaN


valueOf方法，如果存在任意原始值，他就讲对象转换为原始值，如果不存在，返回原对象
new String('234').valueOf()
"234"

new Date().valueOf()
1576022432100


对象到字符串的转换：
  如果对象有toString方法，调用，如果它返回一个原始值，js将这个值转换为字符串，返回结果
  如果对象没有toString方法，或者这个方法不返回一个原始值，那么调用valueOf方法，如果存在valueOf，调用它，如果返回值是原始值，js将转换为字符串，返回此结果
  无法从这两个方法获得原始值，抛错


对象到数字的转换
  如果对象有valueOf方法，后者返回一个原始值，则js将这个原始值转换为数字（如果需要的话）并返回这个数字。
  否则，如果对象有toString方法，后者返回一个原始值，则js将其转换并返回。
  抛错

对象转换为数字的细节，解释了为什么空数组会被转换为数字0，为什么具有单个元素的数组同样会转换城一个数字，数组继承了默认的valueOf方法,这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString方法,空数组转换成为空字符串，空字符串转换城数字0，含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数据只包含一个数字元素，这个数字转换成字符串，再转换为数字。

  这里只到这步不香吗，我们已经不是刚走出校园的懵懂少年了，而是即将放飞理想的有志青年。 


  ```

  那些以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格。但在开始和结尾处的任意非空格字符都不会被当成是数字的一部分，都为NaN。


  == 的转换规则

  主要记录比较类型不同的情况
  如果一个值是null，另一个是undefined，则它们相等
  如果一个值是数字，另一个是字符串，将字符串转换位数字，再进行比较
  如果其中一个值是true,或false，转换为1，0再比较
  如果一个值是对象，另一个值是数字或字符串，将对象转换成对应类型

  instanceof操作符的左边不是对象，直接返回false，右边不是函数，抛类型错误

  o instanceof f 
  先计算f.prototype,然后在原型链中查找o,如果能找到，那么o是f或f父类的一个实例，返回true，如果f.prototype不再o的原型链中，那么o就不是f的实例，返回false

   Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高,ToPrimitive 抽象操作规则


   强制类型转换是 JavaScript 开发人员最头疼的问题之一，它常被诟病为语言设计上的一个
缺陷.隐式强制类型转换的作用是减少冗余，让代码更简洁。


null 是基本类型中唯一的一个“假值”  

 
##  字符串和数字间的相互转换
```js
var a = [1,2];
var b = [3,4];
a + b; // "1,23,4"
```
因为数组的
valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()。因此上例中的两
个数组变成了 "1,2" 和 "3,4"。+ 将它们拼接后返回 "1,23,4"。


a+""和String(a)有什么区别？？
根据
ToPrimitive 抽象操作规则
a + "" 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象
操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。它们最后返回的都是字符串，但如果 a 是对象而非数字结果可能会不一样！
var a = {
 valueOf: function() { return 42; },
 toString: function() { return 4; }
};
a + ""; // "42"
String( a ); // "4"





## 隐式强制类型转换为布尔值
最容易出错

## == 和===的区别

宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相
等”，但是它们之间有一个很重要的区别，特别是在判断条件上。
常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。听起来蛮有道理，然而
还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。
正确的解释是：“== 允许在相等比较中进行强制类型转换，而 === 不允许。”

我们来看一看两种解释的区别。
根据第一种解释（不准确的版本），=== 似乎比 == 做的事情更多，因为它还要检查值的
类型。第二种解释中 == 的工作量更大一些，因为如果值的类型不同还需要进行强制类型
转换。
有人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级
（百万分之一秒）的差别而已。
如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎
实现上的细微差别之外，它们之间并没有什么不同。
如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就用 ===，不用在乎性能。

(1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。
(2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。

(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；
(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。



var x = true;
var y = "42";
x == y; // false
Type(x) 是布尔值，所以 ToNumber(x) 将 true 强制类型转换为 1，变成 1 == "42"，二者的
类型仍然不同，"42" 根据规则被强制类型转换为 42，最后变成 1 == 42，结果为 false。
"42" 是一个真值没错，但 "42" == true 中并没有发生布尔值的比较和强制类型转换。这里
不是 "42" 转换为布尔值（true），而是 true 转换为 1，"42" 转换为 42。

重点是我们要搞清楚 == 对不同的类型组合怎样处理。== 两边的布尔值会被强制类型转换
为数字。

var a="42";

// 不要这样用，条件判断不成立：
if (a == true) {
 // ..
}


(1) 如果 x 为 null，y 为 undefined，则结果为 true。
(2) 如果 x 为 undefined，y 为 null，则结果为 true。





null == false // false  ???为什么？？？不适用上面的原则
null == 0 // false
null+3 // 3

if (a == 2 && a == 3) {
 // ..
}
把那道题拿过来说一下
千万不要这样，也不要因此而抱怨强制类型转换。对一种机制的滥用并不能成
为诟病它的借口。我们应该正确合理地运用强制类型转换，避免这些极端的情况。

(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；
(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。

[42] == 42 // true
[ 42 ] 首先调用 ToPromitive 抽象操作（参见 4.2 节），返回 "42"，变成 "42" == 42，然后
又变成 42 == 42，最后二者相等。





"0" == null; // false
"0" == undefined; // false
"0" == false; // true -- 晕！
"0" == NaN; // false
"0" == 0; // true
"0" == ""; // false
false == null; // false
false == undefined; // false
false == NaN; // false
false == 0; // true -- 晕！
false == ""; // true -- 晕！
false == []; // true -- 晕！
false == {}; // false
"" == null; // false
"" == undefined; // false
"" == NaN; // false
"" == 0; // true -- 晕！
"" == []; // true -- 晕！
"" == {}; // false
0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == []; // true -- 晕！
0 == {}; // false


2 == [2]; // true  2== '2'
"" == [null]; // true   ''==''


var a = { b: 42 };
var b = { b: 43 };
a < b; // ??
结果还是 false，因为 a 是 [object Object]，b 也是 [object Object]，所以按照字母顺序
a < b 并不成立。
下面的例子就有些奇怪了：
var a = { b: 42 };
var b = { b: 43 };
a < b; // false
a == b; // false
a > b; // false
a <= b; // true
a >= b; // true


为什么 a == b 的结果不是 true ？它们的字符串值相同（同为 "[object Object]"），按道
理应该相等才对？实际上不是这样，你可以回忆一下前面讲过的对象的相等比较。
但是如果 a < b 和 a == b 结果为 false，为什么 a <= b 和 a >= b 的结果会是 true 呢？
因为根据规范 a <= b 被处理为 b < a，然后将结果反转。因为 b < a 的结果是 false，所
以 a <= b 的结果是 true。
这可能与我们设想的大相径庭，即 <= 应该是“小于或者等于”。实际上 JavaScript 中 <= 是
“不大于”的意思（即 !(a > b)，处理为 !(b < a)）。同理 a >= b 处理为 b <= a。



