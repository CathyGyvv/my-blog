null == undefined // true ，没有任何类型转换，可以当作特例
有一方是数字，就像数字转换，
两方为字符串和布尔值，都转换为数组
undefined和null 不能转换为对象
NaN和任何类型的变量相加都为NaN
字符串类型和任何相加都为字符串

Number，parseInt，parseFloat3个的区别。

x + '' // 转换为字符串
+x // 数字
!!x // 布尔值

## 主要在于+和==的类型转换
特例:
  {}+[] // [object,object]

parseint() ,parseFloat必须以数字开头，否则NaN


valueOf方法，如果存在任意原始值，他就讲对象转换为原始值，如果不存在，返回原对象
new String('234').valueOf()
"234"

new Date().valueOf()
1576022432100


对象到字符串的转换：
  如果对象有toString方法，调用，如果它返回一个原始值，js将这个值转换为字符串，返回结果
  如果对象没有toString方法，或者这个方法不返回一个原始值，那么调用valueOf方法，如果存在valueOf，调用它，如果返回值是原始值，js将转换为字符串，返回此结果
  无法从这两个方法获得原始值，抛错


对象到数字的转换
  如果对象有valueOf方法，后者返回一个原始值，则js将这个原始值转换为数字（如果需要的话）并返回这个数字。
  否则，如果对象有toString方法，后者返回一个原始值，则js将其转换并返回。
  抛错

对象转换为数字的细节，解释了为什么空数组会被转换为数字0，为什么具有单个元素的数组同样会转换城一个数字，数组继承了默认的valueOf方法,这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString方法,空数组转换成为空字符串，空字符串转换城数字0，含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数据只包含一个数字元素，这个数字转换成字符串，再转换为数字。

  这里只到这步不香吗，我们已经不是刚走出校园的懵懂少年了，而是即将放飞理想的有志青年。 


  ```

  那些以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格。但在开始和结尾处的任意非空格字符都不会被当成是数字的一部分，都为NaN。


  == 的转换规则

  主要记录比较类型不同的情况
  如果一个值是null，另一个是undefined，则它们相等
  如果一个值是数字，另一个是字符串，将字符串转换位数字，再进行比较
  如果其中一个值是true,或false，转换为1，0再比较
  如果一个值是对象，另一个值是数字或字符串，将对象转换成对应类型

  instanceof操作符的左边不是对象，直接返回false，右边不是函数，抛类型错误

  o instanceof f 
  先计算f.prototype,然后在原型链中查找o,如果能找到，那么o是f或f父类的一个实例，返回true，如果f.prototype不再o的原型链中，那么o就不是f的实例，返回false

   Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高