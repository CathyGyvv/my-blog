JavaScript中的变量有基本数据类型和引用数据类型，怎么判断数据类型？？  

常见的有3种方式

1. typeOf，适用于基本数据类型。 

2. instanceOf，引用数据类型。

3. Object.prototype.toString.call()属于通用的方法，可以精准判断。

####  typeOf 
用 typeOf 判断null，返回 Object ,《高程》上表示null是一个空对象指针，《你不知道的JavaScript》上表示，这是一个存在已久的BUG，这里就仁者见仁智者见智了，不纠结到底是什么说法了。那就不能用typeOf去判断null的类型了吗？？  
当然有方法  

```js
!a && typeof a === "object"
```
只要满足这两个条件，就能断定a为null类型。



其实不光null比较特殊，undefined也有它的特殊之处。  


大多数开发者倾向于将 undefined 等d同于 undeclared（未声明），但在 JavaScript 中它们完全是两回事。


已在作用域中声明但还没有赋值的变量，是undefined类型。相反，还没有在作用域中声明过的变量，是 undeclared 的。


```js
var a;
a; // undefined
b; // ReferenceError: b is not defined
```
浏览器对这类情况的处理很让人抓狂。上例中，“b is not defined”容易让人误以为是“b is
undefined”。这里再强调一遍，“undefined”和“is not defined”是两码事。此时如果浏览器
报错成“b is not found”或者“b is not declared”会更准确。
更让人抓狂的是 typeof 处理 undeclared 变量的方式更加让人混淆这两种情况。

```js
var a;
typeof a; // "undefined"
typeof b; // "undefined"
```

对于 undeclared（或者 not defined）变量，typeof 照样返回 "undefined"。请注意虽然 b 是
一个 undeclared 变量，但 typeof b 并没有报错。这是因为 typeof 有一个特殊的安全防范
机制，就是这个机制，容易让人有误解。
### instanceOf 


instanceof操作符的左边不是对象，直接返回false，右边不是函数，抛类型错误。 

o instanceof f 
  先计算f.prototype,然后在原型链中查找o,如果能找到，那么o是f或f父类的一个实例，返回true，如果f.prototype不再o的原型链中，那么o就不是f的实例，返回false


### Object.prototype.tostring.call()
这里有坑，就是
Object.prototype.tostring()和function.prototype.
tostring()，Array.prototype.toString()都不一样。

```js
Object.prototype.toString.call({}) // [Object Object]
Object.prototype.toString.call([]) // [Object Array]
Object.prototype.toString.call(function(){}) // [Object Function]

function fn(){}
fn.toString() // 'function fn(){}',这里的toString是Function.prototype.toString

var arr = [1,2,3];
arr.toString() // 1,2,3，这里的toString是Array.prototype.toString
```
Array.prototype上的toString方法是经过重写的，跟join方法类似。






## 隐式类型转换  
说了这么多，终于到正题了。
JavaScript中的强制类型转换不在本文的介绍范围内，这里只总结隐式类型转换的一些规则。 类型转换是 多数JavaScript 开发人员最头疼的问题之一，它常被诟病为语言设计上的一个
缺陷，比如在实际开发中不建议使用 == ,而是使用===，拒绝隐式强制类型转换，其实根本没必要做这种硬性规定。

宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相
等”，但是它们之间有一个很重要的区别，特别是在判断条件上。
常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。听起来蛮有道理，然而
还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。
正确的解释是：“== 允许在相等比较中进行强制类型转换，而 === 不允许。”

我们来看一看两种解释的区别。
根据第一种解释（不准确的版本），=== 似乎比 == 做的事情更多，因为它还要检查值的
类型。第二种解释中 == 的工作量更大一些，因为如果值的类型不同还需要进行强制类型
转换。
有人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级
（百万分之一秒）的差别而已。
如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎
实现上的细微差别之外，它们之间并没有什么不同。
如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就用 ===，不用在乎性能。（以上摘自《你不知道的JavaScript》）  

举个栗子：
```js
var a = '3';
if(a == 3){
    ...
}
//我非常明确a的类型只会是字符串，就是想判断'3' 是否跟3的值相同，我就会直接这样写
// 而不是

if(parseFloat(a) === 3){
    ...
}
// parseFloat()转换这一步真的很没有必要，只是为了用=== 而用的，这样真的好吗？？？

```

隐式类型转换在这种情况下能减少代码冗余，让代码更简洁，为什么不用呢？？
我个人认为，只要掌握隐式类型转换的规则，==和===，都有它的用处。
先上表格
| 值 | 转换为字符串 | 转换为数字 |转换为布尔值|
| ------ | ------ | ------ | ------|
| undefined | 'undefined' | NaN |  false  |
| null | 'null' | 0 |  false  |
| ''(空字符串) |  | 0 |  false  |
| '3'(非空，数字) |  | 3 |  true  |
| 'one'(空字符串) |  | NaN |  true  |
| [] | '' | 0 |  true  |
| [8] | '8' | 8 |  true  |
| [5,'6'] | '5,6' | NaN |  true  |
| function(){} | 'function(){}' | NaN |  true  |
| {a:1} | [object,object] | NaN |  true  |


注意：
那些以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格。但在开始和结尾处的任意非空格字符都不会被当成是数字的一部分，都为NaN。
例子：
```js
parseFloat('3') // 3
parseFloat('X3') // NaN
parseFloat(' 3') // 3
```

### 运算符'+'的类型转换  

+运算中其中一方为字符串，那么就会把另一方也转换为字符串,也就是任何类型的变量和字符串相加，结果都是字符串。  
NaN和任何类型的变量相加都为NaN  
其余情况都会把运算符的两边的基本类型变量转换为number类型进行运算，对象会转换为原始值，注意，对象会转换为原始值。
```js
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"，这里是把[1,2,3]转换为原始类型的值

'a' + + 'b' // -> "aNaN"   相当于'a'+(+'b'),(+'b')为NaN
```

先说一下valueOf方法，如果存在任意原始值，就将对象转换为原始值，如果不存在，返回原对象
new String('234').valueOf()
"234"

new Date().valueOf()
1576022432100



下面详细总结一下对象转换为原始值的规则：
Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，

规范指出，类型转换的内部实现是通过ToPrimitive ( input ，[  PreferredType ] )方法进行转换的，这个方法的作用就是将input转换成一个非对象类型。

参数preferredType是可选的，它的作用是，指出了input被期待转成的类型。
input为日期时preferredType默认为string，input为其他值时preferredType默认为number
如果不传preferredType进来，默认的是'number'。

如果preferredType的值是"string"，那就先执行toString方法,执行后如果返回原始值，那么返回这个原始值，如果不返回原始值， 再执行valueOf方法，执行后如果返回原始值，那么返回这个原始值，如果不返回原始值，就抛出异常。否则，先执行"valueOf", 后执行"toString"。

由此可见，"toString", "valueOf"的执行顺序，取决于preferred的值。
```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // => 3
```
[Symbol.toPrimitive]的调用优先级最高

```js
var a = [1,2];
var b = [3,4];
a + b; // "1,23,4"
```
因为数组的
valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()。因此上例中的两
个数组变成了 "1,2" 和 "3,4"。+ 将它们拼接后返回 "1,23,4"。


a+""和String(a)有什么区别？？
根据
ToPrimitive 抽象操作规则
a + "" 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象
操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。它们最后返回的都是字符串，但如果 a 是对象而非数字结果可能会不一样！
var a = {
 valueOf: function() { return 42; },
 toString: function() { return 4; }
};
a + ""; // "42"
String( a ); // "4"

下面通过一个比较奇葩的例子，重新捋这个规则  
```js
[]+{} // [object object]
```
+操作符两边都是引用数据类型,要将[]和{}都转换为原始值，再去套用原始值相加的转换规则，先看[],toPrimitive的preferredType值没变，仍为原始值number,先调用valueOf，没有返回原始值，返回了[]本身，再调用toString方法，返回空字符串'',此为原始值，再看{},一样先调用valueOf，返回{}本身，再调用toString方法，返回'[Object Object]',所以[]+{}最后变为了''+'[Object Object]',得出结果。

toPrimitive的preferredType值怎么就会不是默认值了呢？
preferredType的值只有3种情况，default（也就是number）,number,string
const object1 = {
  [Symbol.toPrimitive](hint) {
    if (hint == 'number') {
      return 42;
    }
    return null;
  }
};

console.log(+object1); // preferredType为number
console.log(object1+1); // 默认值
console.log(String(object1)); // preferredType为string
console.log(Number(object1)); // preferredType为number
只有在将对象强制类型转换为基本数据类型的值时，preferredType才会改变


## == 类型转换
下面是 == de 转换规则,按顺序来的
1.先判断是否在对比 null 和 undefined，是的话就会返回 true
2.判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number
3.判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断
4.判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断
5.返回false


注意：
null == undefined // true ，没有任何类型转换，可以当作特例  

var x = true;
var y = "42";
x == y; // false
Type(x) 是布尔值，所以 ToNumber(x) 将 true 强制类型转换为 1，变成 1 == "42"，二者的
类型仍然不同，"42" 根据规则被强制类型转换为 42，最后变成 1 == 42，结果为 false。
"42" 是一个真值没错，但 "42" == true 中并没有发生布尔值的比较和强制类型转换。这里
不是 "42" 转换为布尔值（true），而是 true 转换为 1，"42" 转换为 42。

重点是我们要搞清楚 == 对不同的类型组合怎样处理。== 两边的布尔值会被强制类型转换
为数字。

var a="42";

// 不要这样用，条件判断不成立：
if (a == true) {
 // ..
}


null == false // false 不会有任何类型转换，符合上面规则中的5，直接返回false
null == 0 // false 同上

if (a == 2 && a == 3) {
 // ..
}
把那道题拿过来说一下
千万不要这样，也不要因此而抱怨强制类型转换。对一种机制的滥用并不能成
为诟病它的借口。我们应该正确合理地运用强制类型转换，避免这些极端的情况。

"0" == null; // false
"0" == undefined; // false
"0" == false; // true -- 晕！
"0" == NaN; // false
"0" == 0; // true
"0" == ""; // false
false == null; // false
false == undefined; // false
false == NaN; // false
false == 0; // true -- 晕！
false == ""; // true -- 晕！
false == []; // true -- 晕！
false == {}; // false
"" == null; // false
"" == undefined; // false
"" == NaN; // false
"" == 0; // true -- 晕！
"" == []; // true -- 晕！
"" == {}; // false
0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == []; // true -- 晕！
0 == {}; // false


2 == [2]; // true  2== '2'
"" == [null]; // true   ''==''


var a = { b: 42 };
var b = { b: 43 };
a < b; // ??
结果还是 false，因为 a 是 [object Object]，b 也是 [object Object]，所以按照字母顺序
a < b 并不成立。
下面的例子就有些奇怪了：
var a = { b: 42 };
var b = { b: 43 };
a < b; // false
a == b; // false
a > b; // false
a <= b; // true
a >= b; // true


为什么 a == b 的结果不是 true ？它们的字符串值相同（同为 "[object Object]"），按道
理应该相等才对？实际上不是这样，你可以回忆一下前面讲过的对象的相等比较。
但是如果 a < b 和 a == b 结果为 false，为什么 a <= b 和 a >= b 的结果会是 true 呢？
因为根据规范 a <= b 被处理为 b < a，然后将结果反转。因为 b < a 的结果是 false，所
以 a <= b 的结果是 true。
这可能与我们设想的大相径庭，即 <= 应该是“小于或者等于”。实际上 JavaScript 中 <= 是
“不大于”的意思（即 !(a > b)，处理为 !(b < a)）。同理 a >= b 处理为 b <= a。











