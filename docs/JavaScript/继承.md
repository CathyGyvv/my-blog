## 1.原型链继承
```js
function Parent () {
    this.name = 'kevin';
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child () {

}

//可以这样理解，Child.prototype成为Parent的实例，实例上有_proto_属性，自然可以访问Parent原型上的属性和方法  
// Child.prototype.__proto__ === Parent.prototype // true
Child.prototype = new Parent();

var child1 = new Child();

console.log(child1.getName()) // kevin，注意，getName()不在child1上，在原型对象上
```
缺点:
1.引用类型的属性被所有实例共享。
```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('yayu');
// 修改child1的names属性，child1自身没有这个属性，会去其原型对象上查找，修改了原型对象上的names引用的那个数组
// 注意，names不在child1上，而是在child1的原型对象上
console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy", "yayu"]
// 这个也好理解，Child.prototype是 Parent的实例，Parent函数中的this自然指向Child.prototype，相当于在Child.prototype中声明names属性并赋值一个数组，Child的实例上并没有names属性，都是共享同一个原型对象上的names属性，而实例child1修改Child原型上的引用数据类型的变量，Chlid实例的names属性引用同一个数组，当然变化。
```
2.在创建 Child 的实例时，不能向Parent传参,只能给Child构造函数传参。  
3.Child.prototype被改写了，Child.prototype少了默认存在的constructor,而Parent实例的原型的constructor指向Parent。   


![](https://user-gold-cdn.xitu.io/2019/12/9/16eea6954a257232?w=935&h=632&f=png&s=26408)


## 2.借用构造函数继承
```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {
// 让Parent中的this(指向Parent的实例)指向Child的this(指向Child的实例)，也就是Parent中的this指向Child的实例，实现继承
    Parent.call(this);
}

var child1 = new Child(); // {names: ['kevin', 'daisy']} 因为Parent中的this指向Child的实例，也就是child1,所以names直接声明在child1上

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy"]，names都是分别声明在实例上，不是同一个数组的引用
```

1.避免了引用类型的属性被所有实例共享 ，直接将引用类型的属性在实例上声明，没有共享。  
2.可以在 Child 中向 Parent 传参

缺点：
只能继承父类的实例属性和方法，不能继承原型上的属性/方法,定义在父类实例上的方法不是复用，是每次都创建新方法，不是最优方案


![](https://user-gold-cdn.xitu.io/2019/12/9/16eea76aa6c4f892?w=753&h=638&f=png&s=23839)
## 3.组合继承
原型链继承和经典继承一起用，原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承
```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {

    Parent.call(this, name);
    
    this.age = age;

}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```
优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式  
缺点： 调用了2次Parent函数,有多余的属性。


![](https://user-gold-cdn.xitu.io/2019/12/9/16eea8175bf17c1b?w=968&h=645&f=png&s=31689)




## 4.原型拷贝+借用构造继承  
（单独的原型拷贝不能继承声明在实例上的属性，就是Person中的name,age,sex属性，这里不单独介绍了）

```js
function Person(name,age,sex){
    this.name = name;
    this.age = age;
    this.sex = sex;
}

Person.prototype.eat = function(){
    console.log("正在吃饭")
}


Person.prototype.sleep = function(){
    console.log("正在睡觉")
}


function Man(larynx,beard,name,age,sex,){
    Person.call(this,name,age,sex)
    this.larynx = larynx;
    this.beard = beard;
}


for(var key in Person.prototype){
    Man.prototype[key] = Person.prototype[key]
}

Man.prototype.work = function(){
    console.log('111')
}


var songlei = new Man(10,20);
console.log(songlei);

var p1 = new Person()
console.log(p1)

```
缺点：引用数据类型的值仍然在原型上共享

## 5.原型式继承  
```js
利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。

function object(obj){
  function F(){}
  F.prototype = obj;
  return new F();
}

object()对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。
var person = {
  name: "Nicholas",
  friends: ["Shelby", "Court", "Van"]
};

var anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

var yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie"
缺点：
原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
无法传递参数
另外，ES5中存在Object.create()的方法，能够代替上面的object方法。


```

## 6.寄生继承
```js
核心：在原型式继承的基础上，增强对象，返回构造函数
function createAnother(original){
  var clone = object(original); // 通过调用 object() 函数创建一个新对象
  clone.sayHi = function(){  // 以某种方式来增强对象
    alert("hi");
  };
  return clone; // 返回这个对象
}
复制代码函数的主要作用是为构造函数新增属性和方法，以增强函数
var person = {
  name: "Nicholas",
  friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi(); //"hi"
复制代码
缺点（同原型式继承）：，不能做到函数复用




```



## 7.寄生组合式继承
```js
结合借用构造函数传递参数和寄生模式实现继承
function inheritPrototype(subType, superType){
  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本
  prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
  subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型
}

// 父类初始化实例属性和原型属性
function SuperType(name){
  this.name = name;
  this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
  alert(this.name);
};


// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
function SubType(name, age){
  SuperType.call(this, name);
  this.age = age;
}

// 将父类原型指向子类
inheritPrototype(SubType, SuperType);

// 新增子类原型属性
SubType.prototype.sayAge = function(){
  alert(this.age);
}

var instance1 = new SubType("xyc", 23);
var instance2 = new SubType("lxy", 23);

instance1.colors.push("2"); // ["red", "blue", "green", "2"]
instance1.colors.push("3"); // ["red", "blue", "green", "3"]
```
这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf()
这是最成熟的方法，也是现在库实现的方法

## 8.混入方式继承多个对象
```js
function MyClass() {
     SuperClass.call(this);
     OtherSuperClass.call(this);
}

// 继承一个类
MyClass.prototype = Object.create(SuperClass.prototype);
// 混合其它
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// 重新指定constructor
MyClass.prototype.constructor = MyClass;

MyClass.prototype.myMethod = function() {
     // do something
};
复制代码Object.assign会把  OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。
```

## 9.ES6 的class继承
```js
class Person{
    constructor(name,age,sex){
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    eat(){}

    sleep(){}

 }
	
	
 class Man extends Person{
     constructor(larynx,beard){
     	//实现继承必须使用super
     	super();
     	this.larynx = larynx;
     	this.beard = beard;
     }
    
     work(){}
 } 
	
	
var songlei = new Man()
console.log(songlei)
```


ES5继承和ES6继承的区别


ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.


ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。

[参考书(高程)]高程在这部分原型，原型链，继承写的非常清楚，第6章，建议多看几遍，每一遍都有收获。
[参考博客](https://juejin.im/post/5bcb2e295188255c55472db0)
https://github.com/mqyqingfeng/Blog/issues/16

Object.create()和call一起使用的继承，也很不错，4，8方法来自互联网，其他来自《高程》
