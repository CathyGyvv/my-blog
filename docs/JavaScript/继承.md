## 原型链继承
```js
function Parent () {
    this.name = 'kevin';
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child () {

}

//Child.prototype成为Parent的实例，实例自然可以访问父级原型上的属性和方法，Child.prototype.__proto__ === Parent.prototype // true
Child.prototype = new Parent();

var child1 = new Child();

console.log(child1.getName()) // kevin，注意，getName()不在child1上，在它的原型对象上
```
2个缺点:
引用类型的属性被所有实例共享。
```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('yayu');
// 修改child1的names属性，child1自身没有这个属性，会去其原型对象上查找，修改了原型对象上的names引用的那个数组,注意，names不在child1上，而是在child1的原型对象上
console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy", "yayu"]
// 这个也好理解，Child.prototype是 Parent的实例，Parent函数中的this自然指向Child.prototype，相当于在Child.prototype中声明names属性并赋值，Child的实例上并没有names属性，都是共享同一个原型对象上的names属性，而实例child1修改Child原型上的引用数据类型的变量，Chlid实例的names属性引用同一个数组，当然变化。
```
2.在创建 Child 的实例时，不能向Parent传参,只能给Child构造函数传参。

## 借用构造继承
```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {
// 让Parent中的this(指向Parent的实例)指向Child的this(指向Child的实例)，也就是Parent中的this指向Child的实例，实现继承
    Parent.call(this);
}

var child1 = new Child(); // {names: ['kevin', 'daisy']} 因为Parent中的this指向Child的实例，也就是child1,所以names直接声明在child1上

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy"]
```

1.避免了引用类型的属性被所有实例共享  
// 直接将引用类型的属性在实例上声明，没有共享。  
2.可以在 Child 中向 Parent 传参

缺点
只能继承父类的实例属性和方法，不能继承原型属性/方法,定义在父类实例上的方法不是复用，是每次都创建新方法，不是最优方案
```js
function Parent (name) {
    this.name = name;
}

function Child (name) {
    Parent.call(this, name);
}

var child1 = new Child('kevin');

console.log(child1.name); // kevin

var child2 = new Child('daisy');

console.log(child2.name); // daisy
```


## 组合继承
原型链继承和经典继承一起用，原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承
```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {

    Parent.call(this, name);
    
    this.age = age;

}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```
优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式  
缺点： 调用了2次Parent函数
