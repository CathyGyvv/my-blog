## 实现new  
```js

function create() {
  const obj = new Object();
  const Con = [].shift.call(arguments);

  Object.setPrototypeOf(obj, Con.prototype);

  var ret = Con.apply(obj, arguments);
  return ret instanceof Object ? ret : obj;
};
```

## 实现instanceof
```js
function instanceofFn(obj, targetObj){
  const targetObj=Object.getPrototypeOf(obj);
  while(targetObj){
    if(targetObj==targetObj.prototype) {
      return true
    }

    targetObj = Object.getPrototypeOf(targetObj)
  }

  return false
}
```

## 实现节流
```js
// 用定时器实现的
function throttle(func, wait) {
    var timeout;
    var args;
    var context;

    return function() {
        context = this;
        args = arguments;
        if (!timeout) {
            timeout = setTimeout(function(){
                timeout = null; // wait ms后,下次触发又可以满足if判断了
                func.apply(context, args)
            }, wait)
        }


    }
}
```


## 实现防抖 
```js
// 简单版，可以传参数，this指向也没问题
function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
``` 


## 运动 
```js
function move(obj,json,fn){		
		clearInterval(obj.timer);
		obj.timer = setInterval(function(){
			var bStop = true;
			for(var attr in json){
				var iCur = 0;
				if(attr == "opacity"){
					iCur = parseInt(getStyle(obj,attr)*100);
				}else{
					iCur = parseInt(getStyle(obj,attr));
				}
				var speed = (json[attr] - iCur)/8;
				speed = speed>0?Math.ceil(speed):Math.floor(speed);
	
				
				if(json[attr] !=iCur){
					bStop = false;
				}
	
				if(attr == "opacity"){
					obj.style.opacity = (iCur+speed)/100;
					obj.style.filter = "alpha(opacity:"+(iCur+speed)+")";
				}else{
					obj.style[attr] = (iCur+speed)+"px";
				}
				
	
			}
	
			if(bStop){
				clearInterval(obj.timer);
				fn&&fn();
			}
	
		},30)
}
```

## 实现async 
```js
  const getData = () =>
    new Promise(resolve => setTimeout(() => resolve("data"), 1000));

  function* testG() {
    // await被编译成了yield
    const data = yield getData();
    console.log("data: ", data);
    const data2 = yield getData();
    console.log("data2: ", data2);
    return "success";
  }

  var gen = asyncToGenerator(testG);
  // var dataPromise = gen.next()
  gen();
  function asyncToGenerator(generatorFunc) {
    return function() {
      const gen = generatorFunc.apply(this, arguments);
    
      return new Promise((resolve, reject) => {
        function step(key, arg) {
          let generatorResult;
          try {
            generatorResult = gen[key](arg);
          } catch (error) {
            return reject(error);
          }
          const { value, done } = generatorResult;
          if (done) {
            // 到底了
            return resolve(value);
          } else {
            // 没到底
            return Promise.resolve(value).then(
              val => step("next", val),
              err => step("throw", err)
            );
          }
        }
        step("next");
      });
    };
  }
``` 


## 函数的柯里化 
```js
function curry(fn, args = []) {
    return function(){
        let rest = [...args, ...arguments];
        if (rest.length < fn.length) {
            return curry.call(this,fn,rest);
        }else{
            return fn.apply(this,rest);
        }
    }
}

const curry = (fn, ...args) =>
    args.length < fn.length
        //参数长度不足时，重新柯里化该函数，等待接受新参数
        ? (...arguments) => curry(fn, ...args, ...arguments)
        //参数长度满足时，执行函数
        : fn(...args);
//test
function sum(a,b,c) {
    return a+b+c;
}
let sumFn = curry(sum);
console.log(sumFn(1)(2)(3)); //6
console.log(sumFn(1)(2, 3)); //6
``` 


## call的实现
```js
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  const args = [...arguments].slice(1)
  const result = context.fn(...args)
  delete context.fn
  return result
}
```


## apply的实现 
```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  let result
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```
## bind的实现
```js
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```