### setState

setState不是真正意义上的异步，react内部实现了一个批量更新，把需要更新的nextState push到pendingStates数组中，通过isPending判断有没有在工作，如果工作了，就更新，否则不更新，循环调用updater中的函数时，isPending为true

### 虚拟dom有什么特点

优点：

数据和UI的进一步分离

抽象了原本的渲染过程，实现了跨平台的能力，不局限于浏览器的dom，可以是安卓和ios的原生组件
（因为react的Reconciliation（协调，调度）和render(渲染)是独立的阶段，reconciler（协调器）负责计算树的哪些部分已更改；然后，renderer（渲染器）使用该信息来实际更新渲染的应用程序，
这种分离意味着React DOM和React Native可以使用自己的渲染器，同时共享由React core提供的相同协调器，react 16版本中的fiber重新实现了协调器,尽管渲染器将需要更改以支持（并利用）新体系结构，但它基本上与渲染无关。）

vdom牺牲了部分性能，增加了可维护性，也实现了对dom的集中化操作，在数据改变时先对vdom进行修改，再统一反映到真实dom中，用
最小的代价来更新dom，在这个阶段是提升了效率

缺点：

首次渲染大量dom时，由于多了一层vdom的计算，会比innerHTML插入的慢

vdom在内存中维护了一份dom的副本，占用部分内存

如果vdom大量更改，是合适的，但是单一的，频繁更新的话，vdom会花费更多的时间去处理计算的工作，所以，如果有一个dom节点相对较少的
页面，用vdom可能会更慢


### 讲讲react16中的fiber

react初次render或协调后所生成的一个对象，react16前是通过组件递归遍历而来，react16是以fiber为节点构建成的单链表结构树，其作为真实dom的映射。
之前，React并没有充分利用调度的优势。更新导致立即重新渲染整个子树。彻底革新React的核心算法以利用调度是Fiber背后的驱动思想

计算机通常使用调用堆栈来跟踪程序执行的方式
在处理UI时，问题在于如果一次执行太多工作，可能会导致动画掉帧并显得断断续续
较新的浏览器（和React Native）实现了有助于解决此确切问题的API：requestIdleCallback安排在空闲期间调用的低优先级函数，并requestAnimationFrame安排在下一个动画帧上调用的高优先级函数
如果我们可以自定义调用堆栈的行为来优化呈现UI，那不是很好吗？如果我们可以随意中断调用堆栈并手动操作堆栈帧，那不是很好吗？这就是React Fiber的目的。fiber是堆栈的重新实现，专门用于React组件

重新实现堆栈的优点是，您可以将堆栈帧保留在内存中，并根据需要（以及在任何时候）执行它们
除了调度之外，手动处理堆栈帧还可以释放并发和错误边界等功能