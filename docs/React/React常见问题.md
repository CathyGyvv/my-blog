### setState

setState不是真正意义上的异步，react内部实现了一个批量更新，把需要更新的nextState push到pendingStates数组中，通过isPending判断有没有在工作，如果工作了，就更新，否则不更新，循环调用updater中的函数时，isPending为true。

setState在原生事件中，可以在下面直接拿到修改后的值，是同步的。在setTimeout，是同步的。
### 虚拟dom有什么特点

优点：

数据和UI的进一步分离

抽象了原本的渲染过程，实现了跨平台的能力，不局限于浏览器的dom，可以是安卓和ios的原生组件
（因为react的Reconciliation（协调，调度）和render(渲染)是独立的阶段，reconciler（协调器）负责计算树的哪些部分已更改；然后，renderer（渲染器）使用该信息来实际更新渲染的应用程序，
这种分离意味着React DOM和React Native可以使用自己的渲染器，同时共享由React core提供的相同协调器，react 16版本中的fiber重新实现了协调器,尽管渲染器将需要更改以支持（并利用）新体系结构，但它基本上与渲染无关。）

vdom牺牲了部分性能，增加了可维护性，也实现了对dom的集中化操作，在数据改变时先对vdom进行修改，再统一反映到真实dom中，用
最小的代价来更新dom，在这个阶段是提升了效率

框架的dom操作层需要应对任何上层api可能产生的操作，它的实现必须是普适的。构建实际应用的时候，不可能每一个地方都做手动优化，框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。
React 从来没有说过 “React 比原生操作 DOM 快”

React厉害的地方不是说比原生操作dom快，这句话本身就是错的，而是说不管数据怎么变化，都可以以最小的代价来更新DOM。


缺点：

首次渲染大量dom时，由于多了一层vdom的计算，会比innerHTML插入的慢

vdom在内存中维护了一份dom的副本，占用部分内存

如果vdom大量更改，是合适的，但是单一的，频繁更新的话，vdom会花费更多的时间去处理计算的工作，所以，如果有一个dom节点相对较少的
页面，用vdom可能会更慢

比如我在最顶层组件setState一个简单的数据，react就要对整棵树遍历，对比一遍，而用原生操作dom可能一句代码就搞定了，所有就有了shouldComponentUpdate


### diff算法的策略
1.web UI 中DOM节点跨层级的移动操作特别少，可以忽略不计。（diff对比过程中当发现之前的节点不存在时，该节点及其子节点完全删除掉，不会用于进一步的比较。这样只需要对树进行一次便利，便能完成整个DOM树的比较）


2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。  
3.对于同一层级的一组子节点，可以通过唯一的id进行区分。