脏检查：脏检查其实就是存储所有变量的值，每当可能有变量发生变化需要检查时，就将所有变量的旧值跟新值进行比较，不相等就说明检测到变化，需要更新对应视图。因为它定时检查，而不是直接监听属性变化。脏检查可以实现批处理完数据之后，再去统一更新view。低效的，效率取决于开发者绑定的观察者的数量。

脏数据： 产生了变化的数据 

createStore返回4个函数，dispatch调用时，执行reducer，依次执行subscribe的listener（回调）这其中state的不可变或者是可变全部由使用者来控制，Redux并不知道state有没有发生变化，更不知道state具体哪里发生了变化。 如果在短时间内发生了多次修改（例如用户输入），不可变的开销，加上redux用字符串匹配action的开销，脏检测的开销，再加上view层的开销，整个性能表现会非常糟糕。

再看react-redux做了什么，在store.subscribe上挂回调函数，每次发生subscribe就调用connect传进去 mapStateProps  和  mapDispatchToProps ，然后脏检查props的每一项。

## mobx  
不与任何view层框架相互依赖





Mobx利用getter和setter来收集组件的数据依赖关系，从而在数据发生变化的时候精确知道哪些组件需要重绘，在界面的规模变大的时候，往往会有很多细粒度更新，虽然响应式设计会有额外的开销，在界面规模大的时候，这种开销是远比对每一个组件做脏检查小的，因此在这种情况下Mobx会很容易得到比Redux更好的性能。而在数据全部发生改变时，基于脏检查的实现会比Mobx这类响应式有更好的性能，但这类情况很少