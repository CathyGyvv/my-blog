## 总结

此篇没有实现细节，原理，具体做法，而是从宏观角度的总结。 


## 静态代码分割 
```js
import(...).then()
```
可能需要babel-plugin-syntax-dynamic-import做代码转换

其实就是异步加载资源，这种写法不如React.lazy，做的事都是一样的，建议直接用后者。 

## webpack常用 laoder 和  plugin

1. url-loader  

    将limit匹配的图片转换为base64格式，其内部使用了file-loader,url-loader和file-loader类似，只是多了一步base64的转换， file-loader 默认在内部生成图片，也可以处理字体文件，并打包
    
2. image-webpack-loader   

    压缩图片



3. webpack-dev-server  

    启动静态服务

4. postcss-loader  
    处理css  

    autoprefixer自动加浏览器前缀 

5. eslint-loader  

    做代码格式的优化

6. webpack.DefinePlugin 

    创建一些在编译时可以配置的全局常量，在代码中可以访问

7. CopyWebpackPlugin   

    复制没经过webpack处理的文件

8. webpack.IgnorePlugin 

    忽略指定的模块，不把指定的模块打包（moment.js里有大量的i18n代码,没必要全部打包）
    ```js
    plugins: [
        new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)
      ]
    ```

9. webpack.DllPluginc  

    抽离第三方模块

10. html-webpack-plugin  

    自动创建HTML文件，引用构建出的JS文件

11. css-loader, style-loader,mini-css-extract-plugin

    处理css中的依赖，@import，url引入的文件，style-loader将css-loader解析的结果转变成js代码,运行时插入style标签，mini-css-extract-plugin,将css代码做抽离
  
12.  expose-loader   

      暴露全局变量($表示jquery)  


      ```js
      {
        test: require.resolve('jquery'),
        use: 'expose-loader?$'
      }
      ```    

13. webpack-bundle-analyzer(体积)  


    用于分析 webpack 构建打包的内容，查看各个模块的依赖关系和各个模块的代码体积，便于开发者做性能优化。使用这个可以配合 IgnorePlugin 来过滤掉部分大而无用的第三方模块,


14. BundleAnalyzerPlugin   

    将各个包的内容，信息以图形化界面展现出来  

15. clean-webpack-plugin   


    清除上次打包的文件 

16. uglifyjs-webpack-plugin    


      压缩Js，不支持ES6语法，可以用terser-webpack-plugin代替

17. cache-loader   

    文件较之前的没有发生变化则会直接使用缓存

18. happypack 

    分配任务到子进程，减少构建时间

19. webpack-parallel-uglify-plugin  

    优化代码的压缩时间

20. HotModuleReplacementPlugin  

    开发环境，局部更改刷新,HMR

21. SpeedMeasurePlugin（速度）  

    将每一个plugin，每一个loader的打包时间以及总时长打包统计





## loader的加载方式（按优先级大到小）


前置loader(pre)==> 普通loader（normal） ==> 内联loader(inline)  ==> 后置loader（post）   

前置，后置 
```js
{
  test: /\.less$/,
  use: 'less-loader',
  enforce: 'pre' // pre post  把enforce字段去掉就是普通Loader
}
```

行内loader  
```js
require('!inline-loader!./a.js')
```




## tree shaking 

tree shaking(去除**没有执行到**的代码,css的，js的)，注意，必须开启代码压缩，uglifyjs(代码压缩混淆)，不然没用。  

有副作用的代码即使没有使用到，还是会被保留

tree shaking 中的 sideEffects属性 

sideEffects:false ，在package.json中声明该包模块是否包含 sideEffects(副作用)，从而可以为 tree-shaking 提供更大的优化空间。被标记的模块，不管是否真的有副作用，只要它没有被引用到，就被移出。







## 生产环境
更小的bundle压缩，轻量的source map，优化资源，tree shaking去掉多余代码

## 开发环境
热更新，source map,localhost server,
devtool:cheap-module-eval-source-map 控制sourcemap如何打包 


## webpack提升构建速度
 
 
1. 减少resolve的解析,过滤node_modules，后缀名减少  

2. loader应用的文件范围缩小，include字段指定需要转换的文件范围,modules.rules.noParse   

3. 一处没有必要的plugin，比如生产环境自动压缩代码，去掉无用代码 


4. 选择合适的devtool(sourcemap)


webpack.DLLPlugin将react这种第三方包做抽离,但这种方式有缺点
有些库你并不需要使用到全部功能，比如组件库，函数库，你可以只是需要其它一小部分内容，而 DLLPlugin 插件才不管你这些，它会通通地全部打包进去，这样你就无法去使用打包体积减小的策略了(如：tree shaking)。

像 React、Vue 这样整体性偏强的库，可以生成 vendor 第三方库来去做缓存，因为你一般技术体系是固定的，一个站点里面基本上都会用到统一技术体系，所以生成 vendor 库用于缓存，这部分可以通过 DLLPlugin 去做。
像 antd、lodash 这种功能性组件库，可以通过 tree shaking 来进行消除，只保留有用的代码，千万不要直接打到 vendor 第三方库里，不然你将大量加载执行无用的代码。




polyfill.io 动态加载polyfill




### es6的转换

yarn add babel-loader @babel/core @babel/preset-env -D     
                                       (预设)
配置Loader
```js
{
  test: /\.js$/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: [
        '@babel/preset-env'
      ],
       plugins: [
              '@babel/plugin-proposal-class-properties'
            ]
    }
  }
}
```

### 添加polyfill

yarn add @babel/plugin-transform-runtime @babel/runtime -D
```js
 plugins: [
    '@babel/plugin-proposal-class-properties',
    '@babel/plugin-transform-runtime'
  ]
```

yarn add @babel/polyfill -D
import '@babel/polyfill';
或者
module.exports = {
  entry: ["@babel/polyfill", "./app/js"],
};

### babel-polyfill直接引入太大了（400K），这个问题可以通过单独使用 core-js 的某个类库来解决
如果使用了 babel-runtime、babel-plugin-transform-runtime(在编译中复用辅助函数,createClass) 或者 babel-polyfill，你就可以间接的引入了 core-js 标准库

babel-polyfill把方法都加到原型链上，污染全局变量，所以使用babel-plugin-transform-runtime,它必须把 babel-runtime (包含core-js)当做依赖,也不支持实例方法,（[].includes()）,不会污染全局环境，会在局部进行polyfill, 多次使用只会打包一次，无重复引用

```js
npm install --save-dev @babel/plugin-transform-runtime
npm install --save @babel/runtime

{
    "presets": [
        [
            "@babel/preset-env",
            {
                "useBuiltIns": "usage",
                "corejs": 3
            }
        ]
    ],
    "plugins": [
       "@babel/plugin-transform-runtime"
    ]
}
```
https://www.zoo.team/article/babel-2
https://segmentfault.com/a/1190000018721165


不再需要手动的在代码中引入@babel/polyfill 了，同时还能做到按需加载 
```js
presets: [
          ["@babel/preset-env", { useBuiltIns: 'usage' }]
        ]
```
## useBuiltIns和动态polyfill.io有什么区别 
useBuiltIns
不会注入类似fetch这种浏览器api性质的polyfill的，它只会处理es标准的polyfill 

动态polyfill.io有维护成本的 (第三方的服务不敢保证)

@babel/preset-stage0 , 提案预设只有stage2阶段以上的特性才会在未来被使用，以下的是有可能被废弃的,babel7开始不推荐使用了。


https://zhuanlan.zhihu.com/p/43249121
https://zhuanlan.zhihu.com/p/44174870

@babel/preset-env可以根据我们对browserslist的配置，在转码时自动根据我们对转码后代码的目标运行环境的最低版本要求，采用更加“聪明”的转码，如果我们设置的最低版本的环境，已经原生实现了要转码的ES特性，则会直接采用ES标准写法；如果最低版本环境，还不支持要转码的特性，则会自动注入对应的polyfill


### 提前打包静态文件，比如react,react-dom

plugins: [
  new webpack.DLLReferencePlugin({
    manifest: path.resolve(__dirname,'dist','manifest.json')
  })
]


https://juejin.im/post/5de87444518825124c50cd36#heading-23

https://juejin.im/post/5cfe4b13f265da1bb13f26a8
 



  entry 可以是多入口 
  ```js
  module.export = {
    entry: {
      ...
    }
  }
  ``` 
  entry可以合并多个入口 

  ```js
  module.export = {
    entry: {
      main: [
        ...
      ]
    }
  }
  ```

  entry可以写一个动态入口 
  ```js
  const path = require('path');
  const fs = require('fs');

  // src/pages 目录为页面入口的根目录
  const pagesRoot = path.resolve(__dirname, './src/pages');
  // fs 读取 pages 下的所有文件夹来作为入口，使用 entries 对象记录下来
  const entries = fs.readdirSync(pagesRoot).reduce((entries, page) => {
    // 文件夹名称作为入口名称，值为对应的路径，可以省略 `index.js`，webpack 默认会寻找目录下的 index.js 文件
    entries[page] = path.resolve(pagesRoot, page);
    return entries;
  }, {});

  module.exports = {
    // 将 entries 对象作为入口配置
    entry: entries,

    // ...
  };
  ```


  output 只有一个出口 

  webpack本身只能处理js，loader可以把其他的文件进行转换 

  babel-loader   转换es6,7等新特性的语法  

  ### thread-loader 多进程打包js和css
  每次webpack解析一个模块，thread-loader会将它及它的以来分配给worker线程中




  commonsChunkPlugin 将chunks相同的模块代码提取成公共JS  

  ZipWebpackPlugin 将打包出的资源生成一个zip包 

  resolve.alias可以指定路径，避免在开发中写复杂路径

  ## 为什么import React from 'react'就会去找node_modules里的包？
  ```js
  // webpack默认指定 
  resolve: {
    modules: ['node_modules']
  }
  ```

  ### ES6的转换 

  babel-loader的使用，然后配置.babelrc文件 
  (@babel/core是做什么的)
  ```js
  {
  // plugins中的插件在presets之前运行
  // 执行顺序：从后往前 
    "presets": [
      // 一个presets,表示很多plugins的集合 
      "@babel/preset-env" // 解析es6
      // 核心目的是通过配置得知目标环境的特点，然后只做必要的转换。例如目标浏览器支持 es2015，那么 es2015 这个 preset 其实是不需要的，于是代码就可以小一点(一般转化后的代码总是更长)，构建时间也可以缩短一些。

// 如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)
      "@babel/preset-react" // 解析jsx
    ],
    // 执行顺序：从前往后
    "plugins": [
      // 一个plugins对应一个功能
      "@babel/proposal-class-properties"
    ]
  }
  ```

### 文件指纹  （hash值）

做版本管理 

  hash: 和整个项目的构建相关 ，只要项目文件有修改，整个项目构建的hash值就会更改 

  chunkhash： 和webpack 打包的chunk有关，不同的entry会生成不同的chunkhash值 

  contenthash: 根据文件内容来定义hash，文件内容不变，则contenthash不变 （某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建） 


  js一般指定chunkhash或contenthash 
  css一般指定contenthash
  图片，字体文件一般指定hash （[name].[ext]）,图片文件的hash是由内容决定的 
  

### 压缩文件 
图片压缩： image-webpack-loader
css压缩： optimize-css-assets-webpack-plugin 
js压缩： 生产环境自动压缩 
html压缩： htmlwebpackplugin指定参数  


webpack.optimization.sideEffects ??? 
px2rem-loader,px到rem的转换  


### commonsChunkPlugin代码分离 
```js
  output: {
    filename: 'static/js/[name].[chunkhash:8].js',
    chunkFilename: 'static/js/[name].[chunkhash:8].js'
  },
plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      names: ['vendor', 'manifest'],
      minChunks: Infinity
    }),
],

```


splitChunksPlugin 代替commonsChunkPlugin插件 
optimization.splitchunks 可以做到下面这个
htmlWebpackExternalsPlugin 抽离公共资源 以cdn的形式引入（react,react-dom）
这不是最好的解决方案 

### 预编译资源模块 

思路：将react，react-dom,redux,react-redux等基础包打包成一个文件 

方法：使用DLLPlugin进行分包，DllReferencePlugin 对manifest.json引用 

首先，进行分包,最好新建脚本命令，方便
```js
"script": {
  "dll": 'webpack --config webpack.dll.js'
}
```

```js
// webpack.ddl.js
...
entry: {
  library: [
    'react',
    'react-dom',
    ...
  ]
},
output: {
  filename: '[name]_[hash].dll.js',
  path:path.join(__dirname,'build/library'),
  library: '[name]'
},
plugins: [
  new webpack.DllPlugin({
    name: '[name]_[hash]'
    path: path.join(__dirname,'build/library/[name].json')
  })
]
...
``` 


然后，引入对应的包 
```js
// webpack.prod.js
plugins: [
  new webpack.DllReferencePlugin({
    manifest: require('./build/library/library.json')
  })
]
``` 

最后，需要在html 模板里面引入 dll.js，webpack 不会自动引入



## 减少构建时间 
缩小 Babel 的编译范围，并使用 webpack cache 缓存模块。 

```js
module.exports = {
  // 减小模块的查找范围
  resolve: {
    modules: [path.resolve(__dirname, 'node_modules')],
  },
  module: {
    rules: [
      {
        test: /\.js?$/,
        use: [{
          loader: 'babel-loader',
          query: {
            // 将 babel 编译过的模块缓存在 webpack_cache 目录下，下次优先复用
            cacheDirectory: './webpack_cache/',
          },
        }],
        // 减少 babel 编译范围，忘记设置会让 webpack 编译慢上好几倍
        include: path.resolve(__dirname, 'src'),
      },
    ]
  },
}
``` 




https://github.com/happylindz/blog/issues/7 

https://github.com/happylindz/blog/issues/6