### 复杂度
O，来描述算法的复杂度

O(1)   复杂度和数据量无关，最理想化的一种情况（从数据中取出第i个元素）
O(n)    遍历一次数据

### 冒泡排序

O(n^2)   稳定

```js
function bubleSort(arr){
  var len = arr.length;
  for(let outer = len;outer>=2;outer--) {
    for(let inner =0;inner<=outer-1;inner++){
      if(arr[inner]>arr[inner+1]){
        [arr[inner],arr[inner+1]]=[arr[inner+1],arr[inner]]
      }
    }
  }
  return arr
}
```

### 插入排序（选择排序）

O(n^2) 稳定

```js
function insertSort(arr){
  for(let i=1;i<arr.length;i++){// 外循环从1开始，默认arr[0]是有序列
    for(let j=i;j>0;j--){ // j=i,将从arr[j]依次插入有序段中
       // 为了找到合适的位置插入
       if(arr[j]<arr[j-1]) {
         [arr[j],arr[j-1]]=[arr[j-1],arr[j]]
       }else {
         break;
       }
    }

  }
  return arr
}
```


### 快速排序
 简易版版，占用额外空间

```js
function quickSort(arr){
  if(arr.length<=1){
    return arr
  }

  let left=[];
  let right=[];
  let flag = arr[0]; //随便取一个当标杆
  for(let i=0;i<arr.length;i++) {
    if(arr[i]<flag) {
      left.push(arr[i])
    }else {
      right.push(arr[i])
    }
  }

  return quickSort(left).concat(flag,quickSort(right))
}
```


原理快排
```js
function quickSort1(arr,low=0,high=arr.length-1){
  // low,high是数组两边的游标
  if(low>=high) {
    return 
  }

  let left = low;
  let right = high;
  let flag = arr[left];
  while(left<right){
    // 从右边尝试找比flag小的
    if(left<right && flag <= arr[right]) {
      right--
    }

    arr[left] = arr[right];

    if(left<right && flag>= arr[left]) {
      left++
    }

    arr[right]=arr[left]


  }

  arr[left] = flag;
  quickSort1(arr,low,left-1);
  quickSort1(arr,left+1,high);

  return arr
}
```



### 栈
### 链表 像火车，车厢和车厢之间连接，可以随时替换车厢，react最新架构的fiber，就是从树变成了链表，能够让diff任务随时中断
### 集合  es6中的set
### 哈希表 js中的对象，实际的键值和存入的哈希值之间存在一层映射
```js
class HashTable {
  constructor(){
    this.items={}
  }

  get(key){
    const hash = this.keyToHash(key);
    return this.items[hash]
  }

  set(key,value){
    const hash=this.keyToHash(key);
    this.items[hash] = value
  }

  remove(key){
    const hash = this.keyToHash(key);
    delete this.items[hash]
  }

  keyToHash(key){
    //把字符串key，变成数字
    let hash=0;
    for(let i=0;i<key.length;i++){
      hash+=key.charCodeAt(i) // 获取key的ascll码
    }
    hash = hash%37 
    // 数字会在37以内
    return hash
  }
}


let kkb = new HashTable();
kkb.set('name','nameValue')
console.log(kkb.get('name'))
```

有问题，两个数的hash值一样的时候，会发生哈希碰撞，可以用存储链表的方式来解决（重复的值存在链表里）V8处理的很好了



### 树
浏览器的dom就是树

