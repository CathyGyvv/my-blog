### 栈
先进后出
```js
class Stack {
  constructor() {
    this.stack = []
  }

  // 入栈
  push(item) {
    this.stack.push(item)
  }
  // 出栈
  pop() {
    this.stack.pop()
  }
  // 返回栈顶的元素
  peek() {
    return this.stack[this.getCount() - 1]
  }
  // 返回栈内的元素个数
  getCount() {
    return this.stack.length
  }
  // 清空栈
  clear() {
    this.stack = []
  }
}
```

```js
// 栗子
var isValid = function(s) {
  let map = {
    '(': -1,
    ')': 1,
    '[': -2,
    ']': 2,
    '{': -3,
    '}': 3
  }
  let stack = []
  for (let i = 0; i < s.length; i++) {
    if (map[s[i]] < 0) {
      stack.push(s[i])
    } else {
      let last = stack.pop()
      if (map[last] + map[s[i]] != 0) return false
    }
  }
  if (stack.length > 0) return false
  return true
}



console.log(isValid('{[]}()'))

```

### 队列
先进先出，排队打饭
```js
// 队列
class Queue {
  constructor() {
    this.queue = []
  }

  // 队列尾部添加元素
  enQueue(item) {
    this.queue.push(item)
  }
  // 删除队列头的第一个元素
  deQueue() {
    return this.queue.shift()
  }
  getHeader() {
    return this.queue[0]
  }
  getLength() {
    return this.queue.length
  }
  isEmpty() {
    return this.getLength() === 0
  }
}


```


```js
// 击鼓传花 循环队列
var names = ['a','b','c','d','e','f'];
// 游戏规则
var number = 3; // 传3次就淘汰一个人

function chuanhua (names, number) {
  var q = new Queue();
  for(var i=0;i<names.length;i++){
    q.enQueue(names[i])// 所有项入队列
  }
  
  var taotai;
  // 小于等于1，胜者出现
  while(q.getLength()>1){
    for(var i=0;i<number-1;i++){
      q.enQueue(q.deQueue()) // 先出队列，再进队列，相当于把队列的number前几项 放到后面到后面
    }
    taotai=q.deQueue(); // 删除number对应的项
    console.log('淘汰----'+taotai)
  }
  return q.deQueue() // 胜者
}

```

```js
// 优先队列
var PriorityQueue=function(){
  var items = [];

  this.enqueue = function (element,priority){
    var queueItem = new QueueItem(element,priority);
    var added = false;
    for(var i=0;i<items.length;i++){
      if(queueItem.priority>items[i].prrority){
        items.splice(i,0,queueItem)
        added = true;
        break;
      }
    }

    this.getItems = function() {
      return items
    }

    if(!added){
      items.push(queueItem)
    }
  }
}

// 辅助类
var QueueItem = function (element,priority){
  this.element = element;
  this.priority = priority
}
```
### 链表 
像火车，车厢和车厢之间连接，可以随时替换车厢，react最新架构的fiber，就是从树变成了链表，能够让diff任务随时中断
是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大

```js
var likedLIst = function(){
  // 链表头
  var head = null;
  // 链表长度
  var length = 0;

  // 辅助类：节点
  var Node = function(element){
    this.element = element;
    this.next = null
  }

  // 链表尾添加元素
  this.append = function(element){
    var node=new Node(element);

    if(head == null){
      // 只会在向链表添加第一次的时候执行
      head = node
    }else{
      var current = head;
      while(current.next){
        current=current.next
      }

      //while执行完毕后，current是链表的最后一项
      current.next = node;
      length++;
    }
  }


  //链表某一个位置添加元素
  this.insert = function(position,element){
    //越界
    if(position>-1&&position<length){
      var node = new Node(element);
      
      if(position == 0){
        var current = head;
        head = node;
        head.next = current
      }else {
        var index = 0;
        var current = head;
        var previous = null;
        while(index<position){
           previous = current;
           current = current.next;
           index++;
        }
        previous.next = node;
        node.next = current
      }

      length++
    }
  }

  // 删除某一个位置的元素
  this.removeAt = function(position){
    if(position>-1&&position<length){
      if(position ==0){
         head = head.next;
      }else {
        var current = head;
        var previous = null;
        var index = 0;
        while(index<position){
          previous = current;
          current = current.next;
          index++;
        }

        // 出循环的时候，index == position
        previous.next = current.next
      }


      length--;
      return current //返回删除项
    }
    return null
  }
  //删除某一项
  this.remove = function(element){
    return this.removeAt(this.indexOf(element))
  }

  // 查找
  this.indexOf = function(element){
    var current = head;
    var index = 0;
    while(current){
      if(current.element == element){
        return index
      }
      index++;
      current = current.next
    }

    return -1
  }

  this.isEmpty = function(){
    return length ==0
  }

  this.size = function(){
    return length
  }


  this.getHead = function(){
    return head
  }
}


```


### 集合  es6中的set
### 哈希表 js中的对象，实际的键值和存入的哈希值之间存在一层映射
```js
class HashTable {
  constructor(){
    this.items={}
  }

  get(key){
    const hash = this.keyToHash(key);
    return this.items[hash]
  }

  set(key,value){
    const hash=this.keyToHash(key);
    this.items[hash] = value
  }

  remove(key){
    const hash = this.keyToHash(key);
    delete this.items[hash]
  }

  keyToHash(key){
    //把字符串key，变成数字
    let hash=0;
    for(let i=0;i<key.length;i++){
      hash+=key.charCodeAt(i) // 获取key的ascll码
    }
    hash = hash%37 
    // 数字会在37以内
    return hash
  }
}


let kkb = new HashTable();
kkb.set('name','nameValue')
console.log(kkb.get('name'))
```

有问题，两个数的hash值一样的时候，会发生哈希碰撞，可以用存储链表的方式来解决（重复的值存在链表里）V8处理的很好了



### 树
浏览器的dom就是树

