### 栈
先进后出
```js
class Stack {
  constructor() {
    this.stack = []
  }

  // 入栈
  push(item) {
    this.stack.push(item)
  }
  // 出栈
  pop() {
    this.stack.pop()
  }
  // 返回栈顶的元素
  peek() {
    return this.stack[this.getCount() - 1]
  }
  // 返回栈内的元素个数
  getCount() {
    return this.stack.length
  }
  // 清空栈
  clear() {
    this.stack = []
  }
}
```

```js
// 栗子
var isValid = function(s) {
  let map = {
    '(': -1,
    ')': 1,
    '[': -2,
    ']': 2,
    '{': -3,
    '}': 3
  }
  let stack = []
  for (let i = 0; i < s.length; i++) {
    if (map[s[i]] < 0) {
      stack.push(s[i])
    } else {
      let last = stack.pop()
      if (map[last] + map[s[i]] != 0) return false
    }
  }
  if (stack.length > 0) return false
  return true
}



console.log(isValid('{[]}()'))

```

### 队列
先进先出，排队打饭
```js
// 队列
class Queue {
  constructor() {
    this.queue = []
  }

  // 队列尾部添加元素
  enQueue(item) {
    this.queue.push(item)
  }
  // 删除队列头的第一个元素
  deQueue() {
    return this.queue.shift()
  }
  getHeader() {
    return this.queue[0]
  }
  getLength() {
    return this.queue.length
  }
  isEmpty() {
    return this.getLength() === 0
  }
}


```


```js
// 击鼓传花 循环队列
var names = ['a','b','c','d','e','f'];
// 游戏规则
var number = 3; // 传3次就淘汰一个人

function chuanhua (names, number) {
  var q = new Queue();
  for(var i=0;i<names.length;i++){
    q.enQueue(names[i])// 所有项入队列
  }
  
  var taotai;
  // 小于等于1，胜者出现
  while(q.getLength()>1){
    for(var i=0;i<number-1;i++){
      q.enQueue(q.deQueue()) // 先出队列，再进队列，相当于把队列的number前几项 放到后面到后面
    }
    taotai=q.deQueue(); // 删除number对应的项
    console.log('淘汰----'+taotai)
  }
  return q.deQueue() // 胜者
}

```

```js
// 优先队列
var PriorityQueue=function(){
  var items = [];

  this.enqueue = function (element,priority){
    var queueItem = new QueueItem(element,priority);
    var added = false;
    for(var i=0;i<items.length;i++){
      if(queueItem.priority>items[i].prrority){
        items.splice(i,0,queueItem)
        added = true;
        break;
      }
    }

    if(!added){
      items.push(queueItem)
    }
  }

  this.getItems = function() {
    return items
  }
}

// 辅助类
var QueueItem = function (element,priority){
  this.element = element;
  this.priority = priority
}
```
### 链表 
像火车，车厢和车厢之间连接，可以随时替换车厢，react最新架构的fiber，就是从树变成了链表，能够让diff任务随时中断
是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大

```js
  // 辅助类：节点
  class Node  {
    constructor(element){
      this.element = element;
      this.next = null
    }
  }

  class likedList {
    constructor(){
      // 链表头
      this.head = null;
      // 链表长度
      this.length = 0;
    }



    // 链表尾添加元素
    append (element) {
      var node = new Node(element);

      if (this.head == null) {
        // 只会在向链表添加第一次的时候执行
        this.head = node
        this.length++
      } else {
        var current = this.head;
        while (current.next) {
          current = current.next
        }

        //while执行完毕后，current.next 为null,current是链表的最后一项
        current.next = node;
        this.length++;
      }
    }


    //链表某一个位置添加元素
    insert (position, element) {
      //越界
      if (position > -1 && position < this.length) {
        var node = new Node(element);

        if (position == 0) {
          var current = this.head;
          this.head = node;
          this.head.next = current
          this.length++
        } else {
          var index = 0;
          var current = this.head;
          var previous = null;
          while (index < position) {
            previous = current;
            current = current.next;
            index++;
          }
          previous.next = node;
          node.next = current
        }

        this.length++
      }
    }

    // 删除某一个位置的元素
    removeAt (position) {
      if (position > -1 && position < this.length) {
        if (position == 0) {
          this.head = this.head.next;
        } else {
          var current = this.head;
          var previous = null;
          var index = 0;
          while (index < position) {
            previous = current;
            current = current.next;
            index++;
          }

          // 出循环的时候，index == position
          previous.next = current.next
        }


        this.length--;
        return current //返回删除项
      }
      return null
    }

    //删除某一项
    remove (element) {
      return this.removeAt(this.indexOf(element))
    }

    // 查找
    indexOf (element) {
      var current = this.head;
      var index = 0;
      while (current) {
        if (current.element == element) {
          return index
        }
        index++;
        current = current.next
      }

      return -1
    }


    isEmpty () {
      return this.length == 0
    }

    size () {
      return this.length
    }


    getHead() {
      return this.head
    }
  }



```


### 集合  es6中的set


### 字典
js中的对象

### 哈希表 js中的对象，实际的键值和存入的哈希值之间存在一层映射
```js
class HashTable {
  constructor(){
    this.items={}
  }

  get(key){
    const hash = this.keyToHash(key);
    return this.items[hash]
  }

  set(key,value){
    const hash=this.keyToHash(key);
    this.items[hash] = value
  }

  remove(key){
    const hash = this.keyToHash(key);
    delete this.items[hash]
  }

  keyToHash(key){
    //把字符串key，变成数字
    let hash=0;
    for(let i=0;i<key.length;i++){
      hash+=key[i].charCodeAt() // 获取key的ascll码
    }
    hash = hash%37 
    // 数字会在37以内
    return hash
  }
}


let kkb = new HashTable();
kkb.set('name','nameValue')
console.log(kkb.get('name'))
```

```js
// 哈希冲突问题
// 解决方案1：分离连接 给哈希表的每一项添加链表
// 解决方案2：线性探查  忘后延
```


```js
// 方案1
  class Node {
    constroctor(key,value){
      this.key = key;
      this.value = value;
    }
  }


  class HashTable_L {
    this.items = {}

    keyToHash(key){
      //把字符串key，变成数字
      let hash=0;
      for(let i=0;i<key.length;i++){
        hash+=key[i].charCodeAt() // 获取key的ascll码
      }
      hash = hash%37 
      // 数字会在37以内
      return hash
    }

    set(key,value){
      const hash=this.keyToHash(key);
      if(this.items[hash]){
        // 已经有值的情况下
        this.items[hash].append(new Node(key,value))
      }else {
        // 没值的情况下
        const l = new likeList() // 链表
        this.items[hash] = l;
        this.items[hash].append(new Node(key,value));
      }

      // this.items[hash] = value
    }

    get(key){
      const hash=this.keyToHash(key);
      if(this.items[hash]) {
        // 链表线性查找
        // 跟链表一样，不写了
      }
      return null
    }

    remove(key){
      const hash=this.keyToHash(key);
      if(this.items[hash]) {
        // 删除
      }else {
        return false
      }
    }
  }
```

```js
// 线性探查
var HashTable_X = function (){
  var table = [];
  var loseloseHashCode = function(key){
    var hash = 0;
    for(var i=0;i<key.length;i++){
      hash+=key[i].charCodeAt()
    }
    return hash%37
  }

  var Node = function(key,value){
    this.key = key;
    this.value = value;
  }

  this.put = function(key,value){
    var position = loseloseHashCode(key);
    if(table[position] == undefined){
      table[position] = new Node(key,value)
    }else {
      //这个位置被占了
      var index = position +1;
      while(table[index!== undefined]){
        index++
      }
      table[index] = new Node(key,value)
    }
  }

  this.get = function (key){

  }

  this.remove = function(key){

  }
}

```

```js
// loseloseHashCode的替换方法
var djb2HashCode = function(key){
  var hash = 5831;
  for(var i=0;i<key.length;i++){
    hash = hash*33+key[i].charCodeAt();
  }
  return hash%1013
}
//数学问题，不会有冲突
```




### 树
浏览器的dom就是树

二叉搜索树  特点：每个节点只有两个节点   左侧节点存储比父节点小的值，右侧节点比父节点值大

中序遍历（先遍历左子树，再遍历根节点，再遍历右子树）
前序遍历 （先遍历根节点，再遍历左子树，再遍历右子树）
后续遍历 （先遍历左子树，再遍历右子树，再遍历根节点）

```js
var Tree = function(){
  var Node = function (value){
    this.value = value;
    this.left = null;
    this.right = null;
  }


  var root = null; // 根节点

  //  插入节点
  var insertNode = function(node,newNode){
    if(newNode.value>node.value){
      // 往右走
      if(node.right == null){
        node.right = newNode
      }else {
        insertNode(node.right,newNode) // 递归
      }
    }else if(newNode.value <node.value){
      //往左走
      if(node.left == null){
        node.left = newNode
      }else {
        insertNode(node.left,newNode) // 递归
      }
    }
  }

  this.insert = function(value){
    var newNode = new Node(value);
    if(root == null){
      //空树
      root = newNode
    }else {
      insertNode(root,newNode)
    }
  }

  this.getRoot=function(){
    return root
  }


  // 搜索节点
  this.search = function() {

  }


  // 遍历节点
  this.traverse = function(callback){
    traverse(root,callback)
  }

  var traverse = function(node,callback){
    if(node == null){
      return 
    }
    traverse(node.left,callback)
    traverse(node.right,callback)
    callback(node.value)
  }

  var min = function(node) {
    if(node == null){
      return null
    }

    while(node&&node.left){
      node = node.left
    }

    return node.value
  }


  // 获取最小值
  this.min = function(){
    return min(root)
  }


  this.max = function(){
    return max(root)
  }

  var max = function(node){
    if(node == null){
      return null
    }

    while(node&&node.right){
      node = node.right
    }

    return node.value
  }


  // 删除节点
  var removeNode = function(node,value){
    if(node == null){
      return null
    }

    if(value>node.value){
      // 向右查找
      removeNode(node.right,value)
      return node
    }else if(value<node.value){
      //向左查找
      removeNode(node.left, value)
      return node
    }else {
      //value == node.value
      // 执行删除
      if(node.left==null&&node.right == null){
        //没有子节点
        node = null
        return node
      }

      //只有一个子节点
      if(node.left == null&&node.right){
        return node.right
      }

      if(node.right == null&&node.left){
        return node.left
      }


      // 有两个子节点的条件
      var aux = findMinNode(node.right); // aux 查找到的最小的子节点
      node.value = aux.value
      node.right = removeNode(node.right, aux.value)

      return node
    }
  }


  var findMinNode = function(node){
    if(node == null){
      return null
    }

    white(node&&node.left){
      node = node.left
    }

    return node

  }

  this.remove = function(key){
    root = removeNode(root,key)
  }
}
```

## 图
可以用邻接矩阵表示，非常浪费内存，添加和删除点很麻烦
也可用邻接表

```js
var Graph = function(){
  // 存储顶点
  var vertices = [];

  // 边
  var adjList = {}

  // 添加顶点
  var addVertex = function(v){
    vertices.push(v)
    adjList[v] = [];
  }


  // 添加边
  var addEdge = function(a,b){
    adjList[a].push(b)
    adjList[b].push(a)
  }

  

  // white 未发现的节点 gray已发现  black已探索
  var initColor=function(){
    var color = {};
    for(var i=0;i<vertices.length;i++){
      color[vertices[i]] = 'white'
    }
    return color 
  }

    // 遍历的广度优先
  this.bfs = function (v,callback){
    var color = initColor();
    var queue = new Queue();
    queue.enqueue(v);

    while(!queue.isEmpty()){
      var now = queue.dequeue;
      var bian = adList[now];
      for(var i=0;i<bian.length;i++){
        var w = bian[i];
        if(color[w] === 'white'){
          // 未发现的全部入列，并且标识为已发现
          color[w] = 'gray';
          queue.enqueue(w)
        }
      }
      color[now] = 'black';
      if(callback){
        callback(now)
      }

    }
  }
  // 使用广度优先查找最短路径,先建立关系
  // d 距离
  //pred 回溯点
   this.BFS = function (v,callback){
    // 遍历的广度优先
    var color = initColor();
    var queue = new Queue();
    queue.enqueue(v);

    var d = {}
    var pred = {}
    for(let i=0;i<vertices.length;i++){
      d[vertices[i]] = 0; //初始化
      pred[vertices[i]]= null 
    }

    while(!queue.isEmpty()){
      var now = queue.dequeue;
      var bian = adList[now];
      for(var i=0;i<bian.length;i++){
        var w = bian[i];
        if(color[w] === 'white'){
          // 未发现的全部入列，并且标识为已发现
          color[w] = 'gray';

          //设置回溯点
          pred[w] = now
          d[w]=d[now]+1

          queue.enqueue(w)
        }
      }
      color[now] = 'black';
      if(callback){
        callback(now)
      }

    }

    return {
      d,
      pred
    }
  }


  var dfsVisite = function(u,color,callback){
    color[u] = 'gray'
    var n = adList[u]
    for(var i=0;i<n.length;i++){
      var w = n[i];
      if(color[w]) == 'while'){
        dfsVisite(w,color,callback)

      }
    }

    color[u] = 'block';
    if(callback){
      callback(u)
    }
  }

  // 遍历的深度优先
  ths.dfs = function(v,callback){
    var color = initColor(); //初始化
    dfsVisite(v, color, callback)
  }

 
}


// 使用
var s=g.BFS('A');

//广度优先算法查找最短路径
var zuiduan = function(form,to){
  var v = to;
  var path = new Stack();
  while(v!==from){
    path.push(v)
    v = s.pred[v]
  }
  path.push(v)
  var str = '';
  while(!path.isEmpty()){
    str += path.pop()+ '-'
  }

  str = str.slice(0,str.length-1)
  return str
}

// 图的遍历：广度优先（队列） 深度优先（递归，栈）
```