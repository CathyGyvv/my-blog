### 共有n个台阶，每次只能上1个或者2个，共有多少种方法走完？(斐波那契数列)

```js
// O(2^n)
function fibonacci(n){
  if(n ==1) {
    return 1;
  }
  if(n ==2){
    return 2;
  }

  if(n>2){
    return fibonacci(n-1) + fibonacci(n-2) 
  }
}
```


```js
//递归优化版本 O(n)
var cache = {
  0:1,
  1:1,
  2:2,
};

function fib(n){
  if(n in cache) {
    return cache[n]
  }else {
    cache[n] = fib(n-1) + fib(n-2) 
    return fib(n-1) + fib(n-2) 
  }
}
```


```js
// 优化版本 O(n)
function fib(n){
  let res = new Array(n+1).fill(1);
  res[1] = 1;
  res[2] = 2;
  for(let i=3;i<n+1;i++){
    res[i] = res[i-1]+res[i-2];
  }
  console.log(res)
  return res[n]
}

fib(10) //[1,1,2,3,5,8,13,21,34,55,89]
```

这两种优化方式都是以空间换时间




### 找出数组中两项之和为目标值的下标，返回成一个数组
```js
// 方法1
var twoSum = function(nums, target) {
    let obj = {};
    let len = nums.length;
    for (let i = 0; i < len; i++) {
        let diff = target - nums[i];
        if (obj[diff] >=0 ) {
            return [obj[diff], i];
        }
        obj[nums[i]] = i;
    }
};


twoSum([0, 2, 3, 5, 1, 2], 3);


// 方法2

var twoSum = function(nums, target) {
    let obj = {};
    let len = nums.length;
    for (let i = 0; i < len; i++) {
        let diff = target - nums[i]; // 差值
        if (obj[diff] >=0 ) {
            return [obj[diff], i];
        }
        obj[nums[i]] = i; // obj的key是当前遍历的值，obj的值是索引 
    }
};


console.log(twoSum([0, -2,5, 3, 5, 1, 2], 3));
```


### 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
```js
// 方法1   92ms   38.4MB
var lengthOfLongestSubstring = function(s) {
    let arr = [];
    let max = 0;
    for(let item of s){
        if(arr.includes(item)){
            let index = arr.indexOf(item);
            arr.splice(0, index + 1);
        }
        arr.push(item); 
        max = max > arr.length ? max : arr.length;
    }
    console.log(arr); // 肯定是不对的，但是max是正确的
    return max;
};

// 方法2  128ms  37.8MB
var lengthOfLongestSubstring = function(str) {
 if (!str.length) return 0
    let tmpStr = ''   // 每次循环找到的不含重复字符的子字符串
    let maxStrLen = 0   // 最大不含重复字符的子字符串的长度
    let len = str.length   
    let left = 0  // 不含重复字符的子字符串的左游标
    for (let i = 0; i < len; i++) {
        if (tmpStr.indexOf(str[i]) !== -1) {
          // 存在重复当前str[i]
            left += (str.slice(left, i).indexOf(str[i]) + 1)
            continue
        }
        tmpStr = str.slice(left, i + 1) // 
        maxStrLen = Math.max(maxStrLen, tmpStr.length) //
    }
    return maxStrLen
};


console.log(lengthOfLongestSubstring('abcabcbb')); // abc
console.log(lengthOfLongestSubstring('pwwkew')); // wke
```
