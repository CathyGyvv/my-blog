





### 集合  es6中的set


### 字典
js中的对象

### 哈希表 js中的对象，实际的键值和存入的哈希值之间存在一层映射
```js
class HashTable {
  constructor(){
    this.items={}
  }

  get(key){
    const hash = this.keyToHash(key);
    return this.items[hash]
  }

  set(key,value){
    const hash=this.keyToHash(key);
    this.items[hash] = value
  }

  remove(key){
    const hash = this.keyToHash(key);
    delete this.items[hash]
  }

  keyToHash(key){
    //把字符串key，变成数字
    let hash=0;
    for(let i=0;i<key.length;i++){
      hash+=key[i].charCodeAt() // 获取key的ascll码
    }
    hash = hash%37 
    // 数字会在37以内
    return hash
  }
}


let kkb = new HashTable();
kkb.set('name','nameValue')
console.log(kkb.get('name'))
```

```js
// 哈希冲突问题
// 解决方案1：分离连接 给哈希表的每一项添加链表
// 解决方案2：线性探查  忘后延
```


```js
// 方案1
 
     // 辅助类：节点
    class Node {
      constructor(element) {
        this.element = element;
        this.next = null
      }
    }

    class likedList {
      constructor() {
        // 链表头
        this.head = null;
        // 链表长度
        this.length = 0;
      }



      // 链表尾添加元素
      append(element) {
        var node = new Node(element);

        if (this.head == null) {
          // 只会在向链表添加第一次的时候执行
          this.head = node
          this.length++
        } else {
          var current = this.head;
          while (current.next) {
            current = current.next
          }

          //while执行完毕后，current.next 为null,current是链表的最后一项
          current.next = node;
          this.length++;
        }
      }


      //链表某一个位置添加元素
      insert(position, element) {
        //越界
        if (position > -1 && position < this.length) {
          var node = new Node(element);

          if (position == 0) {
            var current = this.head;
            this.head = node;
            this.head.next = current
            this.length++
          } else {
            var index = 0;
            var current = this.head;
            var previous = null;
            while (index < position) {
              previous = current;
              current = current.next;
              index++;
            }
            previous.next = node;
            node.next = current
          }

          this.length++
        }
      }

      // 删除某一个位置的元素
      removeAt(position) {
        if (position > -1 && position < this.length) {
          if (position == 0) {
            let current = this.head;
            this.head = this.head.next;
            return current.element
          } else {
            var current = this.head;
            var previous = null;
            var index = 0;
            while (index < position) {
              previous = current;
              current = current.next;
              index++;
            }

            // 出循环的时候，index == position
            previous.next = current.next
          }


          this.length--;
          return current.element //返回删除项
        }
        return null
      }

      //删除某一项
      remove(element) {
        return this.removeAt(this.indexOf(element))
      }

      // 查找
      indexOf(key) {
        var current = this.head;
        var index = 0;
        while (current) {
          if (current.element.key == key) {
            return index
          }
          index++;
          current = current.next
        }

        return -1
      }


      isEmpty() {
        return this.length == 0
      }

      size() {
        return this.length
      }


      getHead() {
        return this.head
      }
    }
   
   
   class Node2 {
      constructor(key, value) {
        this.key = key;
        this.value = value;
      }
    }

  
  // 链表和哈希表的结合
  class HashTable_L {
    constructor(){
      this.items = {}
    }

    keyToHash(key){
      //把字符串key，变成数字
      let hash = 0;
      for (let i = 0; i < key.length; i++) {
        hash += key[i].charCodeAt() // 获取key的ascll码
      }
      hash = hash % 37
      // 数字会在37以内
      return hash
    }

    set(key, value){
      const hash = this.keyToHash(key);
      if (this.items[hash]) {
        // 已经有值的情况下
        this.items[hash].append(new Node2(key, value))
      } else {
        // 没值的情况下
        const l = new likedList() // 链表
        this.items[hash] = l;
        this.items[hash].append(new Node2(key, value));
      }
    }

    get(key){
      // key 'az'
      const hash = this.keyToHash(key);
      if (this.items[hash]) {
        // 链表线性查找
        let current = this.items[hash].head;
        while(current.element){
          if(current.element.key == key){
            return current.element.value
          }
          current = current.next
        }
      }
      return null
    }

    remove(key){
      // key 'az'
      const hash = this.keyToHash(key);
      if (this.items[hash]) {
        // 删除
        
        return this.items[hash].remove(key)
      } else {
        return false
      }
    }
  }

  // az   by

  var like = new HashTable_L();
  like.set('az', 123);
  like.set('by', 456);
  like.set('yu', 789);
```

```js
// 线性探查
  class Node {
    constructor(key, value) {
      this.key = key;
      this.value = value;
    }
  }

  class HashTable_X {
    constructor(){
      this.table = []
    }

    loseloseHashCode (key) {
      var hash = 0;
      for (var i = 0; i < key.length; i++) {
        hash += key[i].charCodeAt()
      }
      return hash % 37
    }



    put(key, value) {
      var position = this.loseloseHashCode(key);
      if (this.table[position] == undefined) {
        this.table[position] = new Node(key, value)
      } else {
        //这个位置被占了
        var index = position + 1;
        while (this.table[index] !==undefined) {
          index++
        }
        this.table[index] = new Node(key, value)
      }
    }

    get(key) {
      var position = this.loseloseHashCode(key);

      while(this.table[position].key !== key){
        position+=1;
      }

      return this.table[position].value
    }

    remove(key) {

    }
  }

  var list = new HashTable_X();
  list.put('az',123);
  list.put('by',456);
  list.put('cx',789);
  list.put('yu',9);

```

```js
// loseloseHashCode的替换方法
var djb2HashCode = function(key){
  var hash = 5831;
  for(var i=0;i<key.length;i++){
    hash = hash*33+key[i].charCodeAt();
  }
  return hash%1013
}
//数学问题，不会有冲突
```




### 树
浏览器的dom就是树

二叉搜索树  特点：每个节点只有两个节点   左侧节点存储比父节点小的值，右侧节点比父节点值大

前序遍历 （先遍历根节点，再遍历左子树，再遍历右子树）
中序遍历（先遍历左子树，再遍历根节点，再遍历右子树）
后续遍历 （先遍历左子树，再遍历右子树，再遍历根节点）

```js

```

## 图
可以用邻接矩阵表示，非常浪费内存，添加和删除点很麻烦
也可用邻接表

```js
var Graph = function(){
  // 存储顶点
  var vertices = [];

  // 边
  var adjList = {}

  // 添加顶点
  var addVertex = function(v){
    vertices.push(v)
    adjList[v] = [];
  }


  // 添加边
  var addEdge = function(a,b){
    adjList[a].push(b)
    adjList[b].push(a)
  }

  

  // white 未发现的节点 gray已发现  black已探索
  var initColor=function(){
    var color = {};
    for(var i=0;i<vertices.length;i++){
      color[vertices[i]] = 'white'
    }
    return color 
  }

    // 遍历的广度优先
  this.bfs = function (v,callback){
    var color = initColor();
    var queue = new Queue();
    queue.enqueue(v);

    while(!queue.isEmpty()){
      var now = queue.dequeue;
      var bian = adList[now];
      for(var i=0;i<bian.length;i++){
        var w = bian[i];
        if(color[w] === 'white'){
          // 未发现的全部入列，并且标识为已发现
          color[w] = 'gray';
          queue.enqueue(w)
        }
      }
      color[now] = 'black';
      if(callback){
        callback(now)
      }

    }
  }
  // 使用广度优先查找最短路径,先建立关系
  // d 距离
  //pred 回溯点
   this.BFS = function (v,callback){
    // 遍历的广度优先
    var color = initColor();
    var queue = new Queue();
    queue.enqueue(v);

    var d = {}
    var pred = {}
    for(let i=0;i<vertices.length;i++){
      d[vertices[i]] = 0; //初始化
      pred[vertices[i]]= null 
    }

    while(!queue.isEmpty()){
      var now = queue.dequeue;
      var bian = adList[now];
      for(var i=0;i<bian.length;i++){
        var w = bian[i];
        if(color[w] === 'white'){
          // 未发现的全部入列，并且标识为已发现
          color[w] = 'gray';

          //设置回溯点
          pred[w] = now
          d[w]=d[now]+1

          queue.enqueue(w)
        }
      }
      color[now] = 'black';
      if(callback){
        callback(now)
      }

    }

    return {
      d,
      pred
    }
  }


  var dfsVisite = function(u,color,callback){
    color[u] = 'gray'
    var n = adList[u]
    for(var i=0;i<n.length;i++){
      var w = n[i];
      if(color[w]) == 'while'){
        dfsVisite(w,color,callback)

      }
    }

    color[u] = 'block';
    if(callback){
      callback(u)
    }
  }

  // 遍历的深度优先
  ths.dfs = function(v,callback){
    var color = initColor(); //初始化
    dfsVisite(v, color, callback)
  }

 
}


// 使用
var s=g.BFS('A');

//广度优先算法查找最短路径
var zuiduan = function(form,to){
  var v = to;
  var path = new Stack();
  while(v!==from){
    path.push(v)
    v = s.pred[v]
  }
  path.push(v)
  var str = '';
  while(!path.isEmpty()){
    str += path.pop()+ '-'
  }

  str = str.slice(0,str.length-1)
  return str
}

// 图的遍历：广度优先（队列） 深度优先（递归，栈）
```