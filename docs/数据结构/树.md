### 树
浏览器的dom就是树

二叉搜索树  特点：每个节点只有两个节点   左侧节点存储比父节点小的值，右侧节点比父节点值大

前序遍历 （先遍历根节点，再遍历左子树，再遍历右子树）
中序遍历（先遍历左子树，再遍历根节点，再遍历右子树）
后续遍历 （先遍历左子树，再遍历右子树，再遍历根节点）

3种都是O(n)的时间复杂度
深度，广度也都是O（n）


```js
const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};
/*
         A
        /\
       B  C
      /\   \
    D  E    F
*/
``` 
先序遍历  深度优先(DFS)  
深度优先搜索的本质就是--栈结构 
```js
function preorder(root) {
    if(!root) {
        return 
    }
     
    console.log('当前遍历的结点值是：', root.val)  
    preorder(root.left)  
    preorder(root.right)
}

//  A B D E C F
```

中序遍历
```js
function inorder(root) {
    if(!root) {
        return 
    }
     
    inorder(root.left)  
    console.log('当前遍历的结点值是：', root.val)  
    inorder(root.right)
}

// D B E A C F 
```


后序遍历
```js
function postorder(root) {
    if(!root) {
        return 
    }
     
    postorder(root.left)  
    postorder(root.right)
    console.log('当前遍历的结点值是：', root.val)  
}

// D E B F C A 
```





遍历 广度优先 (BFS) 

跟队列很像，丢弃已访问的坐标、记录新观察到的坐标
```js
function BFS(root) {
    const queue = [] 
    
    queue.push(root)
   
    while(queue.length) {
        const top = queue[0]  
   
        console.log(top.val)
     
        if(top.left) {
            queue.push(top.left)
        }
   
        if(top.right) {
            queue.push(top.right)
        }
        queue.shift() 
    }
}
```



二叉搜索树删除
拿删除节点右子树的最小值