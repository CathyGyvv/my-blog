### 复杂度
O，来描述算法的复杂度

O(1) 常量阶  复杂度和数据量无关，最理想化的一种情况（从数据中取出第i个元素）
O(n) 线性阶   遍历一次数据
O(logn) 对数阶  栗子： i=1 while(i<=n>){i=i*2}   2^x=n x=log2n  复杂度：O(log2n) ==> O(logn)
O(nlogn) 线性对数阶
O(n^2) 平方阶

(低效)
O(2^n) 指数阶
O(n!) 阶乘阶


数组需要一块连续的内存空间来存储,通过下标查询复杂度低，链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，适合插入和删除


冒泡，插入，选择  O（n^2）
快排，归并 O（nlogn）


### 冒泡排序

O(n^2)   稳定

```js
function bubleSort(arr){
  var len = arr.length;
  for(let outer = len;outer>=2;outer--) {
    for(let inner =0;inner<=outer-1;inner++){
      if(arr[inner]>arr[inner+1]){
        [arr[inner],arr[inner+1]]=[arr[inner+1],arr[inner]]
      }
    }
  }
  return arr
}
```

### 插入排序（选择排序）

O(n^2) 稳定

```js
function insertSort(arr){
  for(let i=1;i<arr.length;i++){// 外循环从1开始，默认arr[0]是有序列
    for(let j=i;j>0;j--){ // j=i,将从arr[j]依次插入有序段中
       // 为了找到合适的位置插入
       if(arr[j]<arr[j-1]) {
         [arr[j],arr[j-1]]=[arr[j-1],arr[j]]
       }else {
         break;
       }
    }

  }
  return arr
}
```


### 快速排序
 简易版版，占用额外空间   O(nlogn)

```js
function quickSort(arr){
  if(arr.length<=1){
    return arr
  }

  let left=[];
  let right=[];
  let flag = arr[0]; //随便取一个当标杆
  for(let i=0;i<arr.length;i++) {
    if(arr[i]<flag) {
      left.push(arr[i])
    }else {
      right.push(arr[i])
    }
  }

  return quickSort(left).concat(flag,quickSort(right))
}
```


原理快排
```js
function quickSort1(arr,low=0,high=arr.length-1){
  // low,high是数组两边的游标
  if(low>=high) {
    return 
  }

  let left = low;
  let right = high;
  let flag = arr[left];
  while(left<right){
    // 从右边尝试找比flag小的
    if(left<right && flag <= arr[right]) {
      right--
    }

    arr[left] = arr[right];

    if(left<right && flag>= arr[left]) {
      left++
    }

    arr[right]=arr[left]


  }

  arr[left] = flag;
  quickSort1(arr,low,left-1);
  quickSort1(arr,left+1,high);

  return arr
}
```