1.从输入URL到页面加载完成，发生了什么

DNS（域名解析系统）将url解析为对应的Ip地址，
通过Ip地址找对应的服务器，
跟服务器建立Tcp连接，
向服务端发送请求，
服务端处理完请求把响应数据放在HTTP响应里返回给客户端，
浏览器拿到响应数据开始走渲染的流程。

1.DNS 解析（DNS缓存，DNS prefetch预读）
2.TCP 连接（每次握手急死人，长连接，预连接）
3.HTTP 请求抛出（减少请求，减小请求体积，服务器越远，一次请求就越慢，部署时就把静态资源放在离我们更近的 CDN 上）
4.服务端处理请求，HTTP 响应返回
5.浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户

这5个过程都可以进行性能优化

## 图片的优化
base64的编码方式，对这个图片进行 Base64 编码，浏览器原来是可以理解这个字符串的，它自动就将这个字符串解码为了一个图片，而不需再去发送 HTTP 请求。用于小图
Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）


jpeg,jpg,体积小，加载快，不支持透明，用与大图，有损压缩，不好处理矢量图，颜色对比强烈的图

png 无损压缩，高保真，体积大，用于logo，图标，透明图

svg 体积小，灵活，矢量图不失真，可编程，渲染成本高

雪碧图 减少HTTP请求

## HTTP缓存

浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

Memory Cache
Service Worker Cache
HTTP Cache
Push Cache


HTTP缓存分为强缓存（优先级较高），协商缓存，在命中强缓存失败的情况下，才会走协商缓存。
强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。

expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。
它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。

考虑到 expires 的局限性，HTTP1.1 新增了 Cache-Control 字段来完成 expires 的任务。
expires 能做的事情，Cache-Control 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 expires 的完全替代方案。在当下的前端实践里，我们继续使用 expires 的唯一目的就是向下兼容。

cache-control: max-age=31536000 时间长度。Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准

no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期

no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。

协商缓存依赖于服务端与浏览器之间的通信。

协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。

如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304（如下图）。

